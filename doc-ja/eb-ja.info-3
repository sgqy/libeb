これは ./eb-ja.info、./eb-ja.texi より makeinfo バージョン 4.5
によって作成されました。

INFO-DIR-SECTION CD-ROM Book Utilities
START-INFO-DIR-ENTRY
* eb-ja: (eb-ja).               C library for accessing CD-ROM book.
END-INFO-DIR-ENTRY

   EB Library: CD-ROM 書籍にアクセスするための C ライブラリ, 笠原基之

   Copyright (C) 1998, 99  Motoyuki Kasahara

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by Free Software Foundation, Inc.


File: eb-ja.info,  Node: Search Functions,  Prev: Search Data Types,  Up: Search

関数の詳細
==========

   この節で説明している関数を使うには、次のようにヘッダファイルを読み込
んで下さい。

     #include <eb/eb.h>

 - 機能: int eb_have_word_search (EB_Book *BOOK)
 - 機能: int eb_have_endword_search (EB_Book *BOOK)
 - 機能: int eb_have_exactword_search (EB_Book *BOOK)
     関数 `eb_have_word_search()' は、BOOK が選択中の副本で前方一致検
     索メソッドが利用可能どうかを調べます。 同様に
     `eb_have_endword_search()' は後方一致検索メソッドについて、
     `eb_have_exactword_search()' は完全一致検索メソッドについて利用可
     能どうかを調べます。

     利用可能なら 1 を返します。 メソッドを持っていないか、そもそも副本
     が選択されていない場合は 0 を返します。

 - 機能: int eb_have_keyword_search (EB_Book *BOOK)
     関数 `eb_have_keyword_search()' は、BOOK が選択中の副本で条件検索
     メソッドが利用可能どうかを調べます。

     利用可能なら 1 を返します。 メソッドを持っていないか、そもそも副本
     が選択されていない場合は 0 を返します。

 - 機能: int eb_have_multi_search (EB_Book *BOOK)
     関数 `eb_have_multi_search()' は、BOOK が選択中の副本で複合検索メ
     ソッドが利用可能どうかを調べます。

     最低 1 種類でも利用可能なら 1 を返します。 メソッドを持っていない
     か、そもそも副本が選択されていない場合は 0 を返します。

 - 機能 : EB_Error_Code eb_multi_search_list (EB_Book *BOOK,
          EB_Multi_Search_Code *MULTI_LIST, int *MULTI_COUNT)
     関数 `eb_multi_search_list()' は、BOOK が選択中の副本に用意されて
     いる複合検索を調べ、複合検索コードの一覧を `EB_Multi_Search_Code'
     型の配列にして、MULTI_LIST の指す領域に書き込みます。 配列は、最大
     で `EB_MAX_MULTI_SEARCHES' 個の要素を持ちます。 加えて、複合検索の
     種類数を MULTI_COUNT の指す領域に書き込みます。

     成功すると、関数は `EB_SUCCESS' を返します。 失敗すると、
     SUBBOOK_COUNT の指す領域に 0 を書き込み、原因を示すエラーコードを
     返します。

     あらかじめ、BOOK はいずれかの副本を選択していなくてはなりません。
     選択していない場合は、`EB_ERR_NO_CUR_SUB' を返します。

 - 機能 : EB_Error_Code eb_multi_entry_count (EB_Book *BOOK,
          EB_Multi_Search_Code MULTI_ID, int *ENTRY_COUNT)
     関数 `eb_multi_search_list()' は、BOOK が選択中の副本に用意されて
     いる複合検索 MULTI_ID について調べ、入力語の個数を ENTRY_COUNT の
     指す領域に書き込みます。

     成功すると、関数は `EB_SUCCESS' を返します。 このとき書き込まれる
     入力語の個数は、1 以上 `EB_MAX_MULTI_ENTRIES' 以下になります。 失
     敗すると、ENTRY_COUNT の指す領域には 0 を書き込み、原因を示すエラ
     ーコードを返します。

     あらかじめ、BOOK はいずれかの副本を選択していなくてはなりません。
     選択していない場合は、`EB_ERR_NO_CUR_SUB' を返します。

 - 機能 : EB_Error_Code eb_multi_entry_label (EB_Book *BOOK,
          EB_Multi_Search_Code MULTI_ID, int ENTRY_INDEX, char *LABEL)
     関数 `eb_multi_search_list()' は、BOOK が選択中の副本に用意されて
     いる複合検索 MULTI_ID について調べ、ENTRY_INDEX 番目の検索語の題
     目を LABEL の指す領域に書き込みます。 ENTRY_INDEX は、先頭の検索語
     を 0 番目と数えます。 題目は最長で `EB_MAX_MULTI_LABEL_LENGTH' バ
     イトになります。 この長さに、ナル文字は含みません。

     書籍の文字コード (*note [CD-ROM 書籍と `EB_Book' オブジェクト] デ
     ータ型の詳細: EB_Book Data Types.)  が `EB_CHARCODE_ISO8859_1' な
     ら、題目を表す文字列は ISO 8859-1 になり、それ以外の文字コードな
     ら日本語 EUC になります。

     成功すると、関数は `EB_SUCCESS' を返します。 失敗すると、LABEL の
     指す領域には空文字列を書き込み、原因を示すエラーコードを返します。

     あらかじめ、BOOK はいずれかの副本を選択していなくてはなりません。
     選択していない場合は、`EB_ERR_NO_CUR_SUB' を返します。

 - 機能 : int eb_multi_entry_have_candidates (EB_Book *BOOK,
          EB_Multi_Search_Code MULTI_ID, int ENTRY_INDEX)
     関数 `eb_multi_search_list()' は、BOOK が選択中の副本に用意されて
     いる複合検索 MULTI_ID について調べ、ENTRY_INDEX 番目の検索語が候
     補一覧を持っているかどうか調べます。 ENTRY_INDEX は、先頭の検索語
     を 0 番目と数えます。

     持っていれば 1 を返します。 持っていないか、そもそも副本が選択され
     ていない場合、あるいは MULTI_ID, や ENTRY_INDEX が不正な値だった場
     合は 0 を返します。

 - 機能 : EB_Error_Code eb_multi_entry_candidates (EB_Book *BOOK,
          EB_Multi_Search_Code MULTI_ID, int ENTRY_INDEX, EB_Position
          *POSITION)
     関数 `eb_multi_search_list()' は、BOOK が選択中の副本に用意されて
     いる複合検索 MULTI_ID について調べ、ENTRY_INDEX 番目の検索語の候
     補一覧の位置を POSITION の指す領域に書き込みます。 先頭の検索語が
     0 番目になります。

     成功すると、関数は `EB_SUCCESS' を返します。 失敗すると、POSITIN
     の指す領域には `eb_seek_text()'
     が必ず失敗する位置情報を書き込み、原因を示すエラーコードを返します。

     あらかじめ、BOOK はいずれかの副本を選択していなくてはなりません。
     選択していない場合は、`EB_ERR_NO_CUR_SUB' を返します。

 - 機能 : EB_Error_Code eb_search_word (EB_Book *BOOK, const char
          *INPUT_WORD)
 - 機能 : EB_Error_Code eb_search_endword (EB_Book *BOOK, const char
          *INPUT_WORD)
 - 機能 : EB_Error_Code eb_search_exactword (EB_Book *BOOK, const char
          *INPUT_WORD)
     関数 `eb_search_word()' は、BOOK が選択中の副本に対する前方一致検
     索をリクエストします。 同様に `eb_search_endword()' は後方一致検索
     を、 `eb_search_exactword()' は完全一致検索をリクエストします。

     検索する語は、引数 INPUT_WORD で指定します。 ただし、これらの関数
     は検索をリクエストするだけで、一致したエントリの情報を返すことは
     しません。 一致したエントリの取得には `eb_hit_list()' を使います。
     関数は、成功すると `EB_SUCCESS' を返します。 失敗すると、原因を示
     すエラーコードを返します。 失敗すると、関数を呼び出す前にリクエス
     トしていた検索の状態記録はリセットされますので、その状態のまま
     `eb_hit_list()' を呼び出しても、やはり失敗に終わります。

     書籍の文字コード (*note [CD-ROM 書籍と `EB_Book' オブジェクト] デ
     ータ型の詳細: EB_Book Data Types.)  が `EB_CHARCODE_ISO8859_1' な
     ら、関数に渡す検索語は ISO 8859-1
     で書かれていなければなりません。 それ以外の文字コードの場合は、日
     本語 EUC で書かれていなければなりません。 不正な文字番号を含んでい
     た場合、関数は `EB_ERR_BAD_WORD' を返します。

     加えて、検索語は 1 バイト以上、 `EB_MAX_WORD_LENGTH' (= 255)
     バイト以下でなければなりません。
     この長さに、ナル文字は含みません。 長すぎる場合は、
     `EB_ERR_TOO_LONG_WORD' を、 長さが 0 (空文字列) の場合は
     `EB_ERR_EMPTY_WORD' を返します。

     あらかじめ、BOOK はいずれかの副本を選択していなくてはなりません。
     選択していない場合は、`EB_ERR_NO_CUR_SUB' を返します。 なお、一致
     するエントリが最低 1 個あるかどうかは、戻り値には影響しません。

 - 機能 : EB_Error_Code eb_search_keyword (EB_Book *BOOK, const char *
          const INPUT_WORDS[])
 - 機能 : EB_Error_Code eb_search_multi (EB_Book *BOOK,
          EB_Multi_Search_Code MULTI_ID, const char * const
          INPUT_WORDS[])
     関数 `eb_search_word()' は、BOOK が選択中の副本に対する条件検索を
     リクエストします。 同様に `eb_search_multi()' は複合検索をリクエス
     トします。

     検索する語は、引数 INPUT_WORDS で指定します。 条件検索と複合検索は
     いずれも複数個の検索語を受け付けますので、検索語を配列にして渡し
     ます。 このとき、配列の末尾の要素には `NULL' を置き、配列の終端を
     明示します。

     どちらの関数も検索をリクエストするだけで、一致したエントリの情報を
     返すことはしません。 一致したエントリの取得には `eb_hit_list()' を
     使います。 関数は、成功すると `EB_SUCCESS' を返します。
     失敗すると、原因を示すエラーコードを返します。 失敗すると、関数を
     呼び出す前にリクエストしていた検索の状態記録はリセットされますの
     で、その状態のまま `eb_hit_list()' を呼び出しても、やはり失敗に終
     わります。

     書籍の文字コード (*note [CD-ROM 書籍と `EB_Book' オブジェクト] デ
     ータ型の詳細: EB_Book Data Types.)  が `EB_CHARCODE_ISO8859_1' な
     ら、関数に渡す検索語は ISO 8859-1
     で書かれていなければなりません。 それ以外の文字コードの場合は、日
     本語 EUC で書かれていなければなりません。 不正な文字番号を含んでい
     た場合、関数は `EB_ERR_BAD_WORD' を返します。

     加えて、個々の検索語は `EB_MAX_WORD_LENGTH' (= 255) バイト以下で
     なければなりません。 この長さに、ナル文字は含みません。 長すぎる場
     合は、`EB_ERR_TOO_LONG_WORD' を返します。 長さが 0 バイトの検索語
     は無視されますが、少なくとも 1 個の検索語は長さが 1 以上ないとい
     けません。 長さが 1 以上の検索語が 1 つもないときは、
     `EB_ERR_NO_WORD' を返します。

     末尾の NULL を除いた配列の要素数は、条件検索では `EB_MAX_KEYWORDS'
     以下、複合検索では `EB_MAX_MULTI_ENTRIES'
     以下でなくてはなりません。 個数が多すぎると
     `EB_ERRO_TOO_MANY_WORDS' を返します。 空文字列の要素を差し引いた個
     数ではなく、単純に渡された要素数が上限を超えているとエラーになり
     ますので、注意が必要です。

     あらかじめ、BOOK はいずれかの副本を選択していなくてはなりません。
     選択していない場合は、`EB_ERR_NO_CUR_SUB' を返します。 なお、一致
     するエントリが最低 1 個あるかどうかは、戻り値には影響しません。

 - 機能 : EB_Error_Code eb_hit_list (EB_Book *BOOK, int MAX_HIT_COUNT,
          EB_Hit *HIT_LIST, int *HIT_COUNT)
     関数 `eb_hit_list()' は、あらかじめ以下のいずれかの関数でリクエス
     ト された検索を実行し、一致したエントリを取得します。

        * `eb_search_word()'  (前方一致検索)

        * `eb_search_endword()'  (後方一致検索)

        * `eb_search_exactword()'  (完全一致検索)

        * `eb_search_keyword()'  (条件検索)

        * `eb_search_multi()'  (複合検索)

     したがって、この関数を呼ぶ前に、上記のいずれかの関数の呼び出しに成
     功していなくてはなりません。

     `eb_hit_list()' は最大で HIT_COUNT 個の一致エントリを HIT_LIST に
     書き込みます。 そして、書き込んだ一致エントリの数を HIT_COUNT が指
     す領域に書き込みます。
     それ以上の個数の一致エントリが存在する場合、残ったエントリの情報は、
     この関数を繰り返し呼び出すことで得ることができます。

     ただし、以下に挙げた関数を呼び出すと、リクエストした検索に関する状
     態記録がリセットされますので、一致したエントリの取得は継続できな
     くなります。

        * `eb_set_subbook()'

        * `eb_unset_subbook()'

        * `eb_load_all_subbooks()'

        * `eb_bind()'

        * `eb_finalize_book()'

        * `eb_search_word()'

        * `eb_search_endword()'

        * `eb_search_exactword()'

        * `eb_search_keyword()'

        * `eb_search_multi()'

     繰り返し呼んだ場合も、一致したエントリの情報はその都度 HIT_LIST の
     先頭から書き込み、 HIT_COUNT が指す領域に書き込む値も、その回の
     `eb_hit_list()' の呼び出しで書き込んだ一致エントリの数になります。

     成功すると、この関数は `EB_SUCCESS' を返します。 たとえ一致したエ
     ントリがなくても、処理が正常に終了すれば、関数は `EB_SUCCESS' を返
     します。

     失敗すると、HIT_COUNT が指す領域に 0 を書き込み、原因を示すエラー
     コードを返します。 この場合、リクエストしていた検索の状態記録はリ
     セットされますので、 これ以上 `eb_hit_list()' を呼んで、残った一致
     エントリを取得することはできなくなります。

     あらかじめ、BOOK はいずれかの副本を選択していなくてはなりません。
     選択していない場合は、`EB_ERR_NO_CUR_SUB' を返します。 また、先に
     挙げた検索のリクエストが成功していない状態でこの関数を呼ぶと、
     `EB_ERR_NO_PREV_SEARCH' を返します。


File: eb-ja.info,  Node: Text Data,  Next: Local Character,  Prev: Search,  Up: Top

テキストデータ
**************

   テキストデータの取得は、検索と並ぶ重要な機能です。

   ここで言う "テキストデータ (text data)" は、"本文 (text body)" とい
う意味ではありません。 CD-ROM 書籍には確かに本文も存在しますが、本文と
同じデータ形式を用いて書かれたデータが数種類あります。 本書では、これ
らのデータをまとめてテキストデータと呼んでいます。 EB ライブラリが扱え
るテキストデータの種類には、次のものがあります。

   * 見出し

   * 本文

   * メニュー

   * 著作権表示

   * 複合検索の入力語の候補一覧

   本章では、これらのテキストデータの取得と加工方法について説明します。

* Menu:

* Seek and Read Text Data::     テキストデータのシークと読み込み
* Text Data Format::            テキストデータの内部形式
* Hook::                        フック
* Hook and Character Code::     フックと文字コードの関係
* Copyright Notice::            著作権表示
* Menu::                        メニュー
* Multi Candidates::            複合検索の候補一覧
* Stop Code Issue::             区切りコードの問題
* Text Data Sample::            サンプルプログラム
* Text Data Types::             データ型の詳細
* Hook Function Details::       フック関数の詳細
* Hook Code List::              フックコードの一覧
* Hookset Access Functions::    フックセット操作関数の詳細
* Builtin Hook Functions::      組み込みフック関数の詳細
* Text Data Functions::         テキストデータ操作関数の詳細


File: eb-ja.info,  Node: Seek and Read Text Data,  Next: Text Data Format,  Prev: Text Data,  Up: Text Data

テキストデータのシークと読み込み
================================

   UNIX でプログラムを組んだ経験のある方には、ファイルからデータを読み
込む際に用いる `lseek()', `read()' というシステムコールをご存じの方も
多いでしょう。

   EB ライブラリでも、テキストデータの取得には、"シーク (seek)" と "読
み込み (read)" という 2 つの操作で行います。 ただし、EB ライブラリでは
ファイルポインタやディスクリプタはなく、 `EB_Book' オブジェクトを通じて
シークや読み込みの操作を行います。

   また、シーク時に指定する位置も `off_t' 型ではなく、 `EB_Position' 型
(*note [検索] データ型の詳細: Search Data Types.)  のオブジェクトを用い
ます。 たとえば、本文の先頭位置は、`eb_text()' という関数を使って次のよ
うに取得できますが、このときも位置データは `EB_Position' 型オブジェク
ト に書き込まれます。

     EB_Position position;
     
     /* 関数の処理が成功すると、`position' に本文の開始位置が
      * 書き込まれます。 */
     if (eb_text(&book, &position) != EB_SUCCESS) {
         fprintf(stderr, "an error occurs.\n");
         return;
     }

参考までに、`EB_Position' 型の内部構造は、次のようになっています。

     typedef struct EB_Position_Struct EB_Position;
     
     struct EB_Position_Struct {
         int page;     /* ページ番号 */
         int offset;   /* ページ内のオフセット */
     };

   ところで、検索時に一致したエントリの見出しや本文を読み込む際にも、
位置情報の指定には `EB_Position' 型が使われます。 一致したエントリの情
報は、関数 `eb_hit_list()' によって `EB_Hit' という型のオブジェクトに書
き込まれますが、 `EB_Hit' 型は次のように定義されています。 (詳しくは
*note [検索] データ型の詳細: Search Data Types.。)

     typedef struct {
         EB_Position heading;   /* 見出しの位置 */
         EB_Position text;      /* 本文の位置   */
     } EB_Hit;

つまり、このときの見出しと本文の位置も、`EB_Position' 型で表現されてい
るのです。

   では、実際のプログラムを例にして、シークと読み込みを行ってみます。
まずは、シークからです。 これには関数 `eb_seek_text()' を用います。 こ
こでもやはり、位置は `EB_Position' 型で渡します。

     if (eb_seek_text(&book, &position) != EB_SUCCESS) {
         fprintf(stderr, "an error occurs.\n");
         return;
     }

データの種類 (見出し、本文 ...) によらず、テキストデータのシークはすべ
て `eb_seek_text()' で行います。

   ただし、`EB_Book' オブジェクトは、テキストデータの種類別に読み込み
位置を覚えているわけではなく、全種類のテキストデータで共有する位置情報
を 一つ覚えているだけです。 たとえば、本文を読み込んだ後で、別の位置に
シークして見出しを読み込むと、 `EB_Book' は本文の読み込み位置のことは忘
れてしまいます。

   さて、シークが終わったら、データを読み込みます。 読み込もうとするテ
キストデータの種類によって、使用する関数が異なります。 見出しだけは
`eb_read_heading()' を使いますが、それ以外では `eb_read_text()' を使い
ます。

   以下は、`eb_read_text()' の使用例です。

     #define MAX_LENGTH 1000
     char buffer[MAX_LENGTH + 1];
     ssize_t text_length;
     
     if (eb_read_text(&book, NULL, NULL, NULL, MAX_LENGTH,
         text, &text_length) != EB_SUCCESS) {
         fprintf(stderr, "an error occurs.\n");
         return;
     }

成功すると、`text' にはテキストデータが、`text_length' には実際に読み
込んだバイト数が書き込まれます。 テキストは最大で `MAX_LENGTH' バイト書
き込まれます。 テキストデータはさらにナル文字で終端されますので、
`buffer' にはもう 1 バイト分の領域が必要になります。

   `eb_read_heading()' の呼び出し方も、`eb_read_text()' とまったく変わ
りません。

     if (eb_read_heading(&book, NULL, NULL, NULL, MAX_LENGTH,
         text, &text_length) != EB_SUCCESS) {
         fprintf(stderr, "an error occurs.\n");
         return;
     }

   `eb_read_text()' や `eb_read_heading()' で読み込んだテキストデータ
は平文のテキストになっていて、ナル文字で終端されています。

     printf("%s\n", text);   /* 出力してみる */

   読み込みたいテキストデータが長すぎて、 `eb_read_text()' あるいは
`eb_read_heading()'
を一回呼び出しただけでは全部読み込めなかった場合は、再度呼び出すことで
続きのデータを読み込むことができます。


File: eb-ja.info,  Node: Text Data Format,  Next: Hook,  Prev: Seek and Read Text Data,  Up: Text Data

テキストデータの内部形式
========================

   前節の例では、読み込んだテキストデータは、平文テキストになっていまし
た。 けれども、CD-ROM 書籍内に平文テキストのデータが、そのまま収録され
ているわけではありません。

   実際のテキストデータの例を、以下に示します。 左側のブロックは 16 進
数でダンプした様子で、右側はそれを基に JIS X 0208 (日本語のかな漢字) の
文字を表している部分を `[　]' という形に直したものです。

          (16進数によるダンプ)            (可能な部分をかな漢字に変換)
     1f0900011f41010026321f611f042121   1f0900011f410100[Σ]1f611f04[　]
     212721211f053e704a734a541f0a1f04   [：][　]1f05[情][報][編]1f0a1f04
     214e1f0525372530255e1f04214f2121   [［]1f05[シ][グ][マ]1f04[］][　]
     214a237323692367236d236121212370   [（][ｓ][ｉ][ｇ][ｍ][ａ][　][ｐ]
     2372236f236a236523632374214b1f05   [ｒ][ｏ][ｊ][ｅ][ｃ][ｔ][）]1f05

   右側のブロックを見ると、おおよそ平文に近い形でテキストデータが収めら
れていることが分かりますが、ところどころに「文字」ではないデータも含ま
れています。

文字ではない部分は、すべて「エスケープシーケンス」と呼ばれるものです。
エスケープシーケンスとは、テキストデータを出力する際に、改行の禁止や強
調修飾といった制御情報を伝えるための仕組みです。 16 進数の `1f' が、エ
スケープシーケンスの開始を意味します。

   参考までに、上のテキストデータで使われているエスケープシーケンスを
すべて列挙すると、次のようになります。

`1f09 0001'
     字下げ (インデント) の量を指定。 (引数が 0001 なので、字下げ量は 1
     。)

`1f41 0100'
     検索キーの開始。 (引数 0100 の意味については、JIS X 4081 に記述が
     ないため不明。)

`1f61'
     検索キーの終了。

`1f04'
     半角表示の開始。

`1f05'
     半角表示の終了。

`1f0a'
     改行

   前節のプログラムで、読み込んだデータが平文テキストになっていたのは、
実は EB ライブラリが加工処理をしたからです。 つまり、「改行」のように平
文テキストでも表現可能なエスケープシーケンスについては処理し、「検索キ
ーの開始」のように表現できないものについては無視するようにして、平文テ
キストになるように加工していたのです。

しかし、平文テキストは表現力が乏しいので、元のデータには含まれているエ
スケープシーケンスの多くを無視することになってしまいます。 HTML のよう
に、もっと表現力のある形式で出力するなら、無視せずに済むシーケンスを増
やせそうです。 では、HTML 形式でテキストデータを取得する関数が EB ライ
ブラリに用意されているかというと、残念ながらありません。

   その代わりに、かなり手間はかかりますが、自由にテキストデータを加工で
きるための仕組みが用意されています。 それが、次の節で説明する "フック
(hook)" です。 フックを使うことで、テキストデータを柔軟に加工することが
できます。


File: eb-ja.info,  Node: Hook,  Next: Hook and Character Code,  Prev: Text Data Format,  Up: Text Data

フック
======

   特に何も指定しなければ、`eb_read_text()', `eb_read_heading()' が返す
テキストデータの加工は、あらかじめ決められた通りの方法で行われます。 た
とえば、「改行」のエスケープシーケンスに対しては、`\n' を書き込むよう
になっています。

   "フック (hook)" を使うと、こうした加工方法を変えることができます。
フックは、あらかじめ決められたフック設定位置に対して、フック関数を登録
することで有効になります。 フック関数が登録されていると、
`eb_read_text()' や `eb_read_heading()' は、あらかじめ決まったやり方で
データを書き込む代わりに、フック関数を呼び出します。 呼び出されたフッ
ク関数がデータの書き込み処理を行うことで、 `eb_read_text()' や
`eb_read_heading()' から返るテキストデータが変化するというわけです。

   EB ライブラリには、多数のフック設定位置が用意されています。 各エスケ
ープシーケンスには、それぞれ専用にフックが用意されており、 それ以外にも
文字のためのフックが存在します。 (どのようなフック設定位置があるか、詳
しくは *note フックコードの一覧: Hook Code List.。)

   それぞれのフック設定位置は、"フックコード (hook code)" と呼ばれるコ
ード値で識別されます。 たとえば、前述の「改行」のエスケープシーケンスに
対応するフックコードは `EB_HOOK_NEWLINE' になります。

   アプリケーションプログラムがフックを扱うには、フックの集合である "フ
ックセット (hook set)" を用意します。 これは、EB ライブラリで利用可能な
すべてのフック設定位置に対して、どのフック関数を使うのかを記録するため
のオブジェクトです。

   では、実際にどうやってフックセットを扱うのか、説明していきましょう。
フックセットは `EB_Hookset' 型のオブジェクトで表しますので、まず
`EB_Hookset' オブジェクトを用意します。

     EB_Hookset hookset;

   `EB_Hookset' オブジェクトは、`EB_Book' オブジェクトと同様に、 使用前
に必ず初期化する必要があります。

     eb_initialize_hookset(&hookset);

   実際のフック関数は、次のようなものになります。 この例では、フック関
数の中で `eb_write_text_string()' という関数を呼び出して、`<br>' とい
う文字列をテキストデータとして書き込んでいます。

     EB_Error_Code
     hook_newline(EB_Book *book, EB_Appendix *appendix, void *container,
         EB_Hook_Code code, int argc, const unsigned int *argv) {
         eb_write_text_string(book, "<br>");
         return 0;
     }

   関数 `eb_set_hook()' を用いることで、このフック関数をフックセットに
登録することができます。 ただし、まず `EB_Hook' という型のオブジェクト
にいったんフックコードとフック関数を設定し、それを `eb_set_hook()' を
渡してやる必要があります。 ここでは、「改行」を表すエスケープシーケン
スに対して、上記のフック関数を登録してみます。

     EB_Hook hook;
     
     hook.code = EB_HOOK_NEWLINE;   # フックコードをセット
     hook.function = hook_newline;  # フック関数をセット
     eb_set_hook(&hookset, &hook);

なお、同じフック設定位置 (フックコード)
に複数回フック関数を登録しても、 有効になるのは最後に登録したものだけで
すので、注意して下さい。 フック関数として `NULL' を指定すると、登録され
ているフックが解除されます。

   関数 `eb_set_hooks()' (最後に `s' が付く) を使えば、複数のフック関
数を一度に登録できます。

     static const EB_Hook hooks[] = {
         {EB_HOOK_NEWLINE,        hook_newline},
         {EB_HOOK_SET_INDENT,     hook_set_indent},
         {EB_HOOK_WIDE_JISX0208,  hook_set_jisx0208},
         {EB_HOOK_NULL,           NULL}
     };
     
     eb_set_hooks(&hookset, &hooks);

配列の末尾を明示するために、`EB_HOOK_NULL' という特殊なフックコードを
置きます。 この点も注意して下さい。

   こうしてフック関数を登録したフックセットを、 `eb_raed_text()',
`eb_raed_heading()' への引数として渡します。 前節までの例では、`NULL'
を渡していましたが、代わりに `&hookset' を渡してみます。

     if (eb_read_text(&book, NULL, &hookset, NULL, MAX_LENGTH,
         text, &text_length) != EB_SUCCESS) {
         fprintf(stderr, "an error occurs.\n");
         return;
     }

これによって、テキストデータ中に改行を表すエスケープシーケンスがあると、
`\n' の代わりに `<br>' という文字列が書き込まれるようになります。

   `EB_Hookset' オブジェクトを使い終わったら、`eb_finalize_hookset()'
を呼んで後始末をします。

     eb_finalize_hookset(&hookset);


File: eb-ja.info,  Node: Hook and Character Code,  Next: Copyright Notice,  Prev: Hook,  Up: Text Data

フックと文字コードの関係
========================

   前節では、エスケープシーケンスに対するフックを例にとりましたが、この
他 にも、EB ライブラリには文字に対するフックが用意されています。

`EB_HOOK_ISO8859_1'
     ISO 8859-1 (ラテン文字 1)
     文字へのフック。ただし制御文字を除きます。 引数として、ISO 8859-1
     の文字番号がフック関数に渡されます。

`EB_HOOK_NARROW_JISX0208'
     半角の JIS X 0208 (日本語のかな漢字) 文字へのフック。 引数として、
     日本語 EUC で表現した場合の文字番号が、フック関数に渡されます。

`EB_HOOK_WIDE_JISX0208'
     全角の JIS X 0208 (日本語のかな漢字) 文字へのフック。 引数として、
     日本語 EUC で表現した場合の文字番号が、フック関数に渡されます。

`EB_HOOK_GB2312'
     GB 2312 (中国語の簡体字) 文字へのフック。 引数として、中国語 EUC
     で表現した場合の文字番号が、フック関数に渡されます。

`EB_HOOK_NARROW_FONT'
     半角の外字へのフック。 引数として、外字の文字番号が、フック関数に
     渡されます。

`EB_HOOK_WIDE_FONT'
     半角の外字へのフック。 引数として、外字の文字番号が、フック関数に
     渡されます。

いずれも、その文字がテキストデータ中に現れる度に、フック関数が呼び出さ
れ ます。

   上の記述を見ても分かるように、フック関数に渡される文字番号は、書籍の
文字コードに応じて、ISO 8859-1, 日本語 EUC、中国語 EUC のいずれかの文
字コードで表現されたものになります。

   フック関数を登録しなければ、その文字番号がテキストデータとしてそのま
ま 書き込まれます。

   もし、アプリケーションプログラムが、EB ライブラリの内部コードとは異
なる文字コードを使用したい場合は、これらのフックのフック関数を登録して、
コード変換処理をするのも手です。 ただし、一文字毎にフック関数が呼び出さ
れるので、相応の負荷がかかります。

   また、EBXA-C を扱うには、特別な処理が必要です。 EBXA-C では、文字コ
ードとして GB 2312 と JIS X 0208 が使われますが (*note 文字コード :
Character Code.)、EB ライブラリによる標準の処理では、どちらも 0xa1a1
〜 0xfefe にマッピングされて衝突するため、最低でもどちらか一方をフック
して文字の表現方法を変えないと、正しく出力できません。


File: eb-ja.info,  Node: Copyright Notice,  Next: Menu,  Prev: Hook and Character Code,  Up: Text Data

著作権表示
==========

   先に記したように、テキストデータには何種類かあり、その中に "著作権表
示 (copyright notice)" というものがあります。 名前の通り、著作権表示に
関するテキストデータを収めたものです。

一般に、著作権表示は本文とはまったく独立したデータとして用意されます。
したがって、本文を先頭から末尾まで読んでみても、著作権表示はどこにも見
つかりません。

   選択中の副本について、著作権表示の開始位置を知るには `eb_copyright()'
を使います。 この関数は、副本が著作権表示を持っていなければ
`EB_ERR_NO_SUCH_SEARCH' を返しますので、著作権表示の有無も同時に分かり
ます。 (開始位置は取得せずに、有無だけを調べたいときは、
`eb_have_copyright()' という関数が使えます。)

     EB_Position position;
     EB_Error_Code err;
     
     err = eb_copyright(&book, &position);
     if (err == EB_ERR_NO_SUCH_SEARCH) {
         /* 著作権表示はない */
     } else if (err != EB_SUCCESS) {
         /* それ以外のエラー */
        return;
     }

   後は、得られた位置 (`position') にシークして、`eb_read_text()' でテ
キストデータを読み込みます。


File: eb-ja.info,  Node: Menu,  Next: Multi Candidates,  Prev: Copyright Notice,  Up: Text Data

メニュー
========

   本文とは独立したテキストデータとしては、著作権表示の他に "メニュー
(menu)" というものがあります。 メニューは、主に本文の補助となるデータを
収録しています。 代表的なものでは、「前書き (序)」「凡例」といったもの
が挙げられます。

   メニューでは「別項目参照」というエスケープシーケンスを多用して、階層
的 な構造になっているのが一般的です。 このエスケープシーケンスには、参
照先のテキストの位置が記録されています。

   たとえば、ある CD-ROM 書籍のメニューが次のようになっていたとします。
この例では、メニューには 3 つの項目があります。

      * 序文
      * 表記について
      * 奥付

メニューのそれぞれの項目には、参照先があります。 テキストデータの内部表
現では、「序文」「表記について」「奥付」のそれぞれの文字列の前後に別項
目参照開始および終了エスケープシーケンスが付いた形になっています。 視
覚的に分かるように記すと、次のような形になっています。

      * <別項目参照開始シーケンス> "序文" <別項目参照終了シーケンス>
      * <別項目参照開始シーケンス> "表記" <別項目参照終了シーケンス>
      * <別項目参照開始シーケンス> "奥付" <別項目参照終了シーケンス>

   HTML の書き方を知っているなら、`a' タグと言えば分かるのではないかと
思います。

     <a href="./index-ja.html">EB ライブラリのホームページ</a>

   ただし、参照先の位置情報は終了シーケンス側に記載されますので、この点
は HTML とは逆になります。 蛇足ですが、別位置参照はメニューだけでなく、
本文でも一般的に使用されます。

   別項目参照開始および終了シーケンスに対して、それぞれフック
`EB_HOOK_BEGIN_REFERENCE' と `EB_HOOK_END_REFERENCE' が用意されていま
す。 参照先の位置情報は、終了シーケンスへのフック関数に対して、引数とし
て 渡されます。 たとえば、`EB_HOOK_END_REFERENCE' へのフック関数の冒頭
では、次のようにすると良いかも知れません。

     EB_Error_Code
     hook_end_ref(EB_Book *book, EB_Appendix *appendix, void *container,
         EB_Hook_Code code, int argc, const unsigned int *argv)
     {
         EB_Position position;
     
         position.page = argv[1];    # 参照先のページ番号
         position.offset = argv[2];  # 参照先のオフセット

   参照先は、メニューの第 2 層となります。 この書籍の「奥付」の参照先を
辿ったら、次のような表記になっていました。

     ○○堂出版社新国語辞典第 2 版 (EPWING 版)
     第 1 版発行 1988年 2月
     第 2 版発行 1999年 11月
     第 2 版 (EPWING 版) 発行 2000年 2月

同様に「序文」「表記に付いて」の参照先についても、こうした文章データが
用意されていました。 図示すると、メニューの階層は次のようになります。

     　　　　　　　　　　　　┌─────┐
     第１層　　　　　　　　　│メニュー　│
     　　　　　　　　　　　　└──┰──┘
     　　　　　　　　　　　　　　　┃
     　　　　　　　┏━━━━━━━╋━━━━━━━┓
     　　　　　　　┃　　　　　　　┃　　　　　　　┃
     　　　　┌──┸──┐　┌──┸──┐　┌──┸──┐
     第２層　│メニュー　│　│メニュー　│　│メニュー　│
     　　　　└─────┘　└─────┘　└─────┘

この辞書の例では、メニューはここで終わりになっていますが、書籍によって
は さらに第 3 層、第 4 層と続く場合もあります。 また、メニュー全体が均
一の階層数になっているとは限りません。 メニューの参照先が本文や著作権表
示になっていることもあります。

   選択中の副本について、 (第 1 層の) メニューの開始位置を知るには
`eb_menu()' を使います。 この関数は、副本がメニューを持っていなければ
`EB_ERR_NO_SUCH_SEARCH' を返しますので、メニューの有無も同時に分かりま
す。 (開始位置は取得せずに、有無だけを調べたいときは、`eb_have_menu()'
という関数が使えます。)

     EB_Position position;
     EB_Error_Code err;
     
     err = eb_menu(&book, &position);
     if (err == EB_ERR_NO_SUCH_SEARCH) {
         /* メニューはない */
     } else if (err != EB_SUCCESS) {
         /* それ以外のエラー */
        return;
     }

   後は、得られた位置 (`position') にシークして、`eb_read_text()' でテ
キストデータを読み込みます。


File: eb-ja.info,  Node: Multi Candidates,  Next: Stop Code Issue,  Prev: Menu,  Up: Text Data

複合検索の候補一覧
==================

   「複合検索」(*note 複合検索 : Multi Search.) のところで述べたように、
複合検索では、入力語に "候補一覧 (candidates)" が用意されていることが
あります。 これは、入力語として有効な語をあらかじめ列挙しておき、 アプ
リケーションプログラムのユーザに選択させる仕組みです。

たとえば、人名を検索するのために、次のような複合検索があったとします。

     入力語 0: 国・地域
     入力語 1: 時代
     入力語 2: 性別
     入力語 3: キーワード
     入力語 4: キーワード

   このうち、入力語 3 の「性別」には、入力語として有効な語は「男」と「
女」 の 2 つしかないでしょう。 このように、入力語として有効な語が限られ
ている場合に、候補一覧が用意されていることがあります。

候補一覧は検索のためのデータではありますが、内部構造はテキストデータそ
のものです。 ユーザに対して候補を列記した示したテキストを示し、その中の
一つを選択してもらうようになっています。

   しかも、候補一覧のデータ構造はメニューと非常に似ており、メニューの
ような階層構造を持っています (*note メニュー: Menu.)。 たとえば、上の複
合検索の入力語 2 「国・地域」にも候補の一覧を設けるとしたら、最初の階
層は次のようになるかも知れません。

     * 日本 (→選択)
     * 日本以外のアジア (→詳細)
     * ヨーロッパ (→詳細)
     * 北アメリカ (→詳細)
     * その他 (→詳細)

「日本」を選ぶと、そこで入力語が決定されたことになります。しかし、 それ
以外の項目についてはさらに細かく分類された選択肢が用意されています。
ここでは、「北アメリカ」を選んでみましょう。 すると、さらに次のような候
補一覧のデータが提示されます。

     * アメリカ (→選択)
     * カナダ (→選択)

ここで、「アメリカ」「カナダ」を選ぶと、入力語が決定されます。

   次に実際に、EB ライブラリを使ってこうした候補一覧を扱う方法について
説明します。 まず、アプリケーションプログラムは、複合検索の入力語が候補
一覧を持っているかどうかを、確認する必要があるでしょう。
`eb_multi_entry_candidates()' を使うと、候補一覧データの開始位置を取得
することができます。 この関数は、候補一覧を持っていなければ
`EB_ERR_NO_CANDIDATES' を返しますので、候補一覧の有無も分かります。 (
開始位置は取得せずに、有無だけを調べたいときは、
`eb_multi_entry_have_candidates()' という関数が使えます。)

     EB_Position position;
     EB_Error_Code err;
     
     /* `mulit_id', `entry_id' で、どの複合検索の何番目の
      * 入力語について確認するのかを指定します。*/
     err = eb_multi_entry_candidates(&book, multi_id, entry_id, &position);
     if (err == EB_ERR_NO_CANDIDATES) {
         /* この入力語には、候補一覧が用意されていない */
        return;
     } else if (err != EB_SUCCESS) {
         /* それ以外のエラー */
        return;
     }

   後は、得られた位置 (`position') にシークして、`eb_read_text()' でテ
キストデータを読み込みます。 読み込んだテキストでは、候補となる語のそれ
ぞれが候補開始と終了を表すエスケープシーケンスに挟まれた形になっていま
す。

     * <候補開始シーケンス> "日本" <候補終了シーケンス>
     * <候補開始シーケンス> "日本以外のアジア" <候補終了シーケンス>
     * <候補開始シーケンス> "ヨーロッパ" <候補終了シーケンス>
     * <候補開始シーケンス> "北アメリカ" <候補終了シーケンス>
     * <候補開始シーケンス> "その他" <候補終了シーケンス>

   候補開始シーケンスに対しては、フックとして `EB_HOOK_BEGIN_CANDIDATE'
が用意されています。 終了シーケンスに対するフックは 2 種類あって、さら
に次の階層へ続く場合に呼ばれる `EB_HOOK_END_CANDIDATE_GROUP' と、その
語がそのまま入力語の候補となる場合に呼ばれる `EB_HOOK_END_GROUP_LEAF'
に 分かれています。

   次の階層のデータの開始位置は、終了シーケンスのフック関数に、引数とし
て 渡ってきます。 (この点もメニューと同様なので、メニューの解説を参考に
して下さい。)

   終了シーケンスに対するフック関数の中では、`eb_current_candidate()'
という関数が使えます。 この関数は、開始シーケンスと終了シーケンスの間に
挟まれた「候補」の文字列 (ポインタ) を返します。

     const char *candidate;
     
     candidate = eb_current_candidate(book);


File: eb-ja.info,  Node: Stop Code Issue,  Next: Text Data Sample,  Prev: Multi Candidates,  Up: Text Data

区切りコードの問題
==================

   本文は、先頭から末尾まで一本の繋がったデータ列になっています。 英語
辞典なら、最初の単語 `A' から最後の `zzz' までの説明が、すべて一つの「
本文」の中に書かれることになります。

   一般に、アプリケーションプログラムがある単語を検索した際は、本文の中
からその語を説明した部分だけを抜き出して出力することになるでしょう。
しかし、困ったことに CD-ROM 書籍には、単語の説明の終わりを示す印 (エス
ケープシーケンス) が定義されていません。 つまり、ある語の説明部分を正確
に抜き出すことは、電子ブックや EPWING では不可能なのです。

   しかしながら、幸いにも市販の書籍の多くには、単語の説明の終了位置にだ
け 出現する、特有のエスケープシーケンスが存在します。 もちろん、このエ
スケープシーケンスは本来「単語の説明の終了」を示すものではなく別の用途
として用いるのですが、「終了位置」として代用できるという意味です。

   EB ライブラリでは、この「終了位置」の印に使えるエスケープシーケンス
の ことを、"区切りコード (stop code)" と呼んでいます。 EB ライブラリは
区切りコードを自動判定する機能を持っていますが、判定は完璧ではないので
外れることもあります。 外れると本文が途中で途切れたり、本文の続きが延々
と出力されたりします。

   その場合は、明示的に appendix (詳しくは *note appendix (付録) とは :
(ebappendix-ja)What is Appendix.)  で区切りコードを指定することによって
回避できる書籍もありますが、 残念ながら区切りコードがまったく存在しない
書籍も少数ながら存在します。 区切りコードを持たない書籍に対して、有効な
対処方法は今のところありません。

   `eb_read_text()' による本文の取得では、区切りコードが検出された時点
で読み込みを止めます。 さらに繰り返し `eb_read_text()' を呼んでも、区切
りコードより先の本文は読み込めません。

   区切りコードを検出したかどうかの判定には、`eb_is_text_stopped()' を
使います。 この関数は、最後に読み込みを行ったテキストデータの中に、区切
りコードを検出していれば 1 を返します。

   本文以外のテキストデータにも区切りコードの概念は存在しますので、
`eb_is_text_stopped()' を使って区切りコードを検出できます。 本文以外で
は EB ライブラリが確実に区切りを判別できますので、誤判定の問題は起きま
せん。

   見出しにおける区切りは、それぞれの単語の見出しの終了位置となります。
メニューおよび複合検索の候補一覧では、階層化された個々のメニューデータ
の終了位置で区切りと判定されます。 (同一階層に複数個のメニューデータが
あっても、個々のメニューデータで区切られます。) 著作権表示では、全文の
終了位置で区切りと判定されます。


File: eb-ja.info,  Node: Text Data Sample,  Next: Text Data Types,  Prev: Stop Code Issue,  Up: Text Data

サンプルプログラム
==================

     /*
      * 使用方法:
      *     text <book-path> <subbook-index> <number>
      * 例:
      *     text /cdrom 0 10
      * 説明:
      *     <book-path> で指定した CD-ROM 書籍から特定の副本を選び、本文
      *     の先頭から <number> 個分の単語の説明を出力します。
      *
      *     <subbook-index> には、検索対象の副本のインデックスを指定しま
      *     す。インデックスは、書籍の最初の副本から順に 0、1、2 ... に
      *     なります。
      */
     #include "config.h"
     
     #include <stdio.h>
     #include <stdlib.h>
     
     #include <eb/eb.h>
     #include <eb/error.h>
     #include <eb/text.h>
     
     #define MAXLEN_TEXT 1023
     
     int
     main(argc, argv)
         int argc;
         char *argv[];
     {
         EB_Error_Code error_code;
         EB_Book book;
         EB_Subbook_Code subbook_list[EB_MAX_SUBBOOKS];
         int subbook_count;
         int subbook_index;
         EB_Position text_position;
         char text[MAXLEN_TEXT + 1];
         ssize_t text_length;
         int text_count;
         int i;
     
         /* コマンド行引数をチェック。*/
         if (argc != 4) {
             fprintf(stderr, "Usage: %s book-path subbook-index number\n",
                 argv[0]);
             exit(1);
         }
         text_count = atoi(argv[3]);
     
         /* EB ライブラリと `book' を初期化。*/
         eb_initialize_library();
         eb_initialize_book(&book);
     
         /* 書籍を `book' に結び付ける。*/
         error_code = eb_bind(&book, argv[1]);
         if (error_code != EB_SUCCESS) {
             fprintf(stderr, "%s: failed to bind the book, %s: %s\n",
                 argv[0], eb_error_message(error_code), argv[1]);
             goto die;
         }
     
         /* 副本の一覧を取得。*/
         error_code = eb_subbook_list(&book, subbook_list, &subbook_count);
         if (error_code != EB_SUCCESS) {
             fprintf(stderr, "%s: failed to get the subbbook list, %s\n",
                 argv[0], eb_error_message(error_code));
             goto die;
         }
     
         /* 副本のインデックスを取得。*/
         subbook_index = atoi(argv[2]);
     
         /*「現在の副本 (current subbook)」を設定。*/
         if (eb_set_subbook(&book, subbook_list[subbook_index]) < 0) {
             fprintf(stderr, "%s: failed to set the current subbook, %s\n",
                 argv[0], eb_error_message(error_code));
             goto die;
         }
     
         /* テキストの開始位置を取得。*/
         error_code = eb_text(&book, &text_position);
         if (error_code != EB_SUCCESS) {
             fprintf(stderr, "%s: failed to get text information, %s\n",
                 argv[0], eb_error_message(error_code));
             goto die;
         }
     
         /* テキストをシーク。*/
         error_code = eb_seek_text(&book, &text_position);
         if (error_code != EB_SUCCESS) {
             fprintf(stderr, "%s: failed to seek text, %s\n",
                 argv[0], eb_error_message(error_code));
             goto die;
         }
     
         i = 0;
         while (i < text_count) {
             /* テキストを取得。*/
             error_code = eb_read_text(&book, NULL, NULL, NULL, MAXLEN_TEXT,
                 text, &text_length);
             if (error_code != EB_SUCCESS) {
                 fprintf(stderr, "%s: failed to read text, %s\n",
                     argv[0], eb_error_message(error_code));
                 goto die;
             }
             fputs(text, stdout);
     
             if (!eb_is_text_stopped(&book))
                 continue;
     
             fputs("\n----------------------------------------\n", stdout);
     
             /* 次の単語の説明へ移動。*/
             error_code = eb_forward_text(&book, NULL);
             if (error_code == EB_ERR_END_OF_CONTENT)
                 fputs("\n[END]\n", stdout);
             else if (error_code != EB_SUCCESS) {
                 fprintf(stderr, "%s: failed to read text, %s\n",
                     argv[0], eb_error_message(error_code));
                 goto die;
             }
             i++;
         }
     
         /* 書籍と EB ライブラリの利用を終了。*/
         eb_finalize_book(&book);
         eb_finalize_library();
         exit(0);
     
         /* エラー発生で終了するときの処理。*/
       die:
         eb_finalize_book(&book);
         eb_finalize_library();
         exit(1);
     }


File: eb-ja.info,  Node: Text Data Types,  Next: Hook Function Details,  Prev: Text Data Sample,  Up: Text Data

データ型の詳細
==============

   この節で説明しているデータ型を使うには、次のようにヘッダファイルを
読み込んで下さい。

     #include <eb/eb.h>

 - Data type: EB_Hook_Code
     データ型 `EB_Hook_Hook' は、フックの設定位置コードを表します。

     この型は符合付き整数型の別名として定義されていますので、2 つのコー
     ドを 2 項演算子 `==' と `!=' で一致比較することができます。

     EB ライブラリでは、全部で `EB_NUMBER_OF_HOOKS' 個のフックコードを
     定義しています。 定義されている設定位置コードの一覧については、 次
     の節 (*note フックコードの一覧 : Hook Code List.)
     を参照して下さい。

 - Data type: EB_Hook
     データ型 `EB_Hook' は、フックコードとそれに対応するフック関数の組
     を表します。 内部構造は、次のように定義されています。

          typedef struct EB_Hook_Struct EB_Hook;
          
          struct EB_Hook_Struct {
              EB_Hook_Code code;
              EB_Error_Code (*function)(EB_Book *, EB_Appendix *, void *,
                  EB_Hook_Code, int, const unsigned int *);
          };

     アプリケーションプログラムは、直接 `EB_Hook' オブジェクトのメンバ
     を参照したり、セットしたりしても構いません。

 - Data type: EB_Hookset
     データ型 `EB_Hookset' は、フック一式を表します。 EB ライブラリで利
     用可能なすべてのフック設定位置に対して、どのようなフック関数を指
     定するのかを記録するための型です。

     `EB_Hookiset' オブジェクトの操作は、すべて EB ライブラリが用意し
     ている関数で行います。 アプリケーションプログラムは、直接
     `EB_Hookset' オブジェクトのメンバを参照したり、セットしたりすべき
     ではありません。

     `EB_Hookset' オブジェクトを使用する際は、まずそのオブジェクトに対
     して `eb_initialize_hookset()'
     を呼んで初期化しなくてはなりません。


File: eb-ja.info,  Node: Hook Function Details,  Next: Hook Code List,  Prev: Text Data Types,  Up: Text Data

フック関数の詳細
================

   この節では、フック関数の仕様について記します。

   まず、フック関数を呼び出す `eb_read_text()' および
`eb_read_heading()' のプロトタイプは次のようになっています。

     EB_Error_Code
     eb_read_text(EB_Book *book, EB_Appendix *appendix,
         EB_Hookset *hookset, void *container, size_t text_max_length,
         char *text, ssize_t *text_length)

   一方、フック関数のプロトタイプは、次のようになっています。

     EB_Error_Code
     hook_function(EB_Book *book, EB_Appendix *appendix, void *container,
         EB_Hook_Code code, int argc, const unsigned int *argv);

   引数 BOOK, APPENDIX, CONTAINER は、 `eb_read_text()' あるいは
`eb_read_heading()' に渡された値がそのままフック関数にも渡ってきます。

   APPENDIX というのは、書籍に対する補助データを提供するオブジェクトで
す (appendix (付録) について詳しくは *note appendix (付録) とは :
(ebappendix-ja)What is Appendix.)。

   引数 CONTAINER は、アプリケーションプログラムからフック関数に何かデ
ータを渡したいときに使います。

   最後の ARGC と ARGV には、加工前のテキストデータが渡されます。 文字
に対するフックでは、文字コード番号が渡ってきます。 エスケープシーケンス
に対するフックでは、そのシーケンス自体のコード (`1f' で始まるコード)
と、もしあればエスケープシーケンスへの引数をが渡ってきます。 個々のフ
ックにおいて、 ARGC と ARGV にどうような値が渡ってくるのか、詳しくは
*note フックコードの一覧: Hook Code List.。

フック関数の中から次に挙げる関数を呼び出すことで、テキストデータへの書
き込みを行うことができます。

   * `eb_write_text()'

   * `eb_write_text_string()'

   * `eb_write_text_byte1()'

   * `eb_write_text_byte2()'

これらの関数の仕様に関して詳しくは *note [テキストデータ] 関数の詳細 :
Text Data Functions.。

   フック関数が `EB_SUCCESS' 以外の値を返すと、フック関数を呼び出した
`eb_read_text()', `eb_read_heading()' はエラーが発生したものと見なし、
そのエラーコードをそのままアプリケーションプログラムに返します。

   フック関数の中では、 BOOK
に対して以下の関数を呼び出してはいけません。 呼び出したときの動作は、未
定義です。

   * `eb_seek_text()'

   * `eb_read_text()'

   * `eb_read_heading()'

   * `eb_read_rawtext()'

   * `eb_forward_text()'

   * `eb_backward_text()'

   * `eb_set_subbook()'

   * `eb_unset_subbook()'

   * `eb_load_all_subbook()'

   * `eb_bind()'

   * `eb_finalize_book()'

   * `eb_finalize_library()'

