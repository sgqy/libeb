これは ./eb-ja.info、./eb-ja.texi より makeinfo バージョン 4.5
によって作成されました。

INFO-DIR-SECTION CD-ROM Book Utilities
START-INFO-DIR-ENTRY
* eb-ja: (eb-ja).               C library for accessing CD-ROM book.
END-INFO-DIR-ENTRY

   EB Library: CD-ROM 書籍にアクセスするための C ライブラリ, 笠原基之

   Copyright (C) 1998, 99  Motoyuki Kasahara

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by Free Software Foundation, Inc.


File: eb-ja.info,  Node: Hook Code List,  Next: Hookset Access Functions,  Prev: Hook Function Details,  Up: Text Data

フックコードの一覧
==================

   この節で説明しているフックコードを使うには、次のようにヘッダファイル
を 読み込んで下さい。

     #include <eb/text.h>

 - EB_HOOK_NULL:
     `EB_HOOK_NULL' は厳密にはフックではなく、`eb_set_hooks()' で複数
     のフック関数を登録する際に、`EB_Hook' 配列の末尾の要素を示すため
     に用います。
     このフックコードに対して、フック関数は登録できません。

     詳しくは、*note [テキストデータ] フック関数の詳細 : Text Data
     Functions.。

 - EB_HOOK_INITIALIZE:
     `EB_HOOK_INITIALIZE' は、`eb_seek_text()' を呼び出した直後の最初
     の `eb_read_text()', `eb_read_heading()' の呼び出し時に処理されま
     す。 何か初期化処理をしたいときに、使うと良いでしょう。

     このフックが、フック関数に渡す `argc' は 0 です。 フック関数を登録
     していない状態では、このフックはテキストデータに何も書き込みませ
     ん。

 - EB_HOOK_BEGIN_NARROW:
 - EB_HOOK_END_NARROW:
     `EB_HOOK_BEGIN_NARROW' および `EB_HOOK_END_NARROW' は、 半角表示の
     開始と終了を表すエスケープシーケンスに対するフックです。

     どちらのフックも、フック関数に渡す `argc' は 1 です。 `argv[0]' は
     エスケープシーケンスのコードそのもので、 `EB_HOOK_BEGIN_NARROW' な
     ら `0x1f04'、 `EB_HOOK_END_NARROW' なら `0x1f05' になります。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。

 - EB_HOOK_BEGIN_SUBSCRIPT:
 - EB_HOOK_END_SUBSCRIPT:
     `EB_HOOK_BEGIN_SUBSCRIPT' および `EB_HOOK_END_SUBSCRIPT' は、 下付
     き表示の開始と終了を表すエスケープシーケンスに対するフックです。

     どちらのフックも、フック関数に渡す `argc' は 1 です。 `argv[0]' の
     値はエスケープシーケンスのコードそのもので、
     `EB_HOOK_BEGIN_SUBSCRIPT' なら `0x1f06'、 `EB_HOOK_END_SUBSCRIPT'
     なら `0x1f07' になります。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に 何も書き込みません。

 - EB_HOOK_SET_INDENT:
     `EB_HOOK_SET_INDENT' は、テキストデータの行頭の字下げ指定を表すエ
     スケープシーケンスに対するフックです。

     このフックが、フック関数に渡す `argc' は 2 です。 `argv[0]' はエス
     ケープシーケンスのコードそのもので、 `0x1f09' になります。
     `argv[1]' が、字下げの量を表します。

     字下げの量の単位が、何であるのかは不明です。 また、字下げ量の最小
     値は、0 の場合と 1 の場合の二通りがあります。 いずれにしろ、字下げ
     は 1 ずつ増えたり減ったりします。

     フック関数を登録していない状態では、このフックはテキストデータに何
     も 書き込みません。

 - EB_HOOK_NEWLINE:
     `EB_HOOK_SET_NEWLINE' は、改行を表すエスケープシーケンスに対する
     フックです。

     ただし、`eb_read_heading()' (見出しの読み込み) による処理では、 改
     行を表すエスケープシーケンスは区切りコードとしても扱われます。 そ
     のため、エスケープシーケンスが見つかってもこのフックの処理は行われ
     ず、 ただちに読み込み処理は終了します。

     このフックが、フック関数に渡す `argc' は 1 です。 `argv[0]' はエス
     ケープシーケンスのコードそのもので、`0x1f0a' になります。

     フック関数を登録していない状態では、このフックはテキストデータに何
     も 書き込みませんが、`eb_initialize_hookset()' で `EB_Hook' オブジ
     ェクトを初期化すると、フック関数として `eb_hook_newline()' が自動
     的に登録されます。

 - EB_HOOK_BEGIN_SUPERSCRIPT:
 - EB_HOOK_END_SUPERSCRIPT:
     `EB_HOOK_BEGIN_SUPERSCRIPT' および `EB_HOOK_END_SUPERSCRIPT' は、
     上付き表示の開始と終了を表すエスケープシーケンスに対するフックです。

     どちらのフックも、フック関数に渡す `argc' は 1 です。 `argv[0]' は
     エスケープシーケンスのコードそのもので、
     `EB_HOOK_BEGIN_SUPERSCRIPT' なら `0x1f0e'、
     `EB_HOOK_END_SUPERSCRIPT' なら `0x1f0f' になります。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。

 - EB_HOOK_BEGIN_NO_NEWLINE:
 - EB_HOOK_END_NO_NEWLINE:
     `EB_HOOK_BEGIN_NO_NEWLINE' および `EB_HOOK_END_NO_NEWLINE' は、 改
     行禁止の開始と終了を表すエスケープシーケンスに対するフックです。

     どちらのフックも、フック関数に渡す `argc' は 1 です。 `argv[0]' は
     エスケープシーケンスのコードそのもので、
     `EB_HOOK_BEGIN_NO_NEWLINE' なら `0x1f10'、
     `EB_HOOK_END_NO_NEWLINE' なら `0x1f11' になります。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。

 - EB_HOOK_BEGIN_EMPHASIS:
 - EB_HOOK_END_EMPHASIS:
     `EB_HOOK_BEGIN_EMPHASIS' および `EB_HOOK_END_EMPHASIS' は、 強調表
     示の開始と終了を表すエスケープシーケンスに対するフックです。

     どちらのフックも、フック関数に渡す `argc' は 1 です。 `argv[0]' は
     エスケープシーケンスのコードそのもので、 `EB_HOOK_BEGIN_EMPHASIS'
     なら `0x1f12'、 `EB_HOOK_END_EMPHASIS' なら `0x1f13' になります。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。

 - EB_HOOK_BEGIN_CANDIDATE:
 - EB_HOOK_END_CANDIDATE_LEAF:
 - EB_HOOK_END_CANDIDATE_GROUP:
     `EB_HOOK_BEGIN_CANDIDATE' は、複合検索の候補となる語の開始を表す
     エスケープシーケンスに対するフックです。

     それに対して、終了を表すエスケープシーケンスに対するフックは 2 種
     類あります。 一つは `EB_HOOK_END_CANDIDATE_LEAF' で、候補となる語
     が実際に検索の入力語として使えるものであることを示します。 もう一
     つは `EB_HOOK_END_CANDIDATE_GROUP' で、候補となる語はさらに細かい
     選択肢に分かれていることを示します。 (したがって、候補となる語を検
     索の入力語として使うことはできません。)

     フック `EB_HOOK_BEGIN_CANDIDATES' が、フック関数に渡す `argc' は 1
     です。 `argv[0]' はエスケープシーケンスのコードそのもので、 `0x1f43'
     になります。

     フック `EB_HOOK_END_CANDIDATE_LEAF' および
     `EB_HOOK_END_CANDIDATE_GROUP' が、フック関数に渡す `argc' は 3 で
     す。 どちらのフックも、`argv[0]' はエスケープシーケンスのコードそ
     のもので、 `0x1f63' になります。 フック
     `EB_HOOK_END_CANDIDATE_GROUP' の `argv[1]' と `argv[2]' は、次の階
     層の候補一覧データの開始ページ番号とオフセットです。 これは、
     `EB_Position' オブジェクト (*note [検索] データ型の詳細 : Search
     Data Types.)  の `page' および `offset' メンバの値に相当します。
     フック `EB_HOOK_END_CANDIDATE_LEAF' では、 `argv[1]', `argv[2]' は
     2 つとも 0 になっています。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。

 - EB_HOOK_BEGIN_REFERENCE:
 - EB_HOOK_END_REFERENCE:
     `EB_HOOK_BEGIN_REFERENCE' および `EB_HOOK_END_REFERENCE' は、 別位
     置のテキストデータの参照開始と終了を表すエスケープシーケンスに対
     するフックです。

     フック `EB_HOOK_BEGIN_REFERENCE' が、フック関数に渡す `argc' は 2
     です。 `argv[0]' はエスケープシーケンスのコードそのもので、 `0x1f42'
     になります。 `argv[1]' の意味は不明です。

     `EB_HOOK_END_REFERENCE' が、フック関数に渡す `argc' は 3 です。
     `argv[0]' はエスケープシーケンスのコードそのもので、`0x1f62' にな
     ります。 `argv[1]' と `argv[2]' は、参照先のページ番号とオフセット
     です。 これは、`EB_Position' オブジェクト (*note [検索] データ型の
     詳細: Search Data Types.)  の `page' および `offset' メンバの値に
     相当します。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。

 - EB_HOOK_BEGIN_KEYWORD:
 - EB_HOOK_END_KEYWORD:
     `EB_HOOK_BEGIN_KEYWORD' および `EB_HOOK_END_KEYWORD' は、 検索キー
     の開始と終了を表すエスケープシーケンスに対するフックです。

     フック `EB_HOOK_BEGIN_KEYWORD' が、フック関数に渡す `argc' は 2 で
     す。 `argv[0]' はエスケープシーケンスのコードそのもので、`0x1f41'
     になります。 `argv[1]' の意味は不明です。

     `EB_HOOK_END_KEYWORD' は、フック関数に 1 個の引数を渡します。
     `argv[0]' はエスケープシーケンスのコードそのもので、`0x1f61' にな
     ります。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。

 - EB_HOOK_BEGIN_DECORATION:
 - EB_HOOK_END_DECORATION:
     `EB_HOOK_BEGIN_DECORATION' および `EB_HOOK_END_DECORATION' は、文
     字修飾の開始と終了を表すエスケープシーケンスに対するフックです。

     フック `EB_HOOK_BEGIN_DECORATION' が、フック関数に渡す `argc' は 2
     です。 `argv[0]' はエスケープシーケンスのコードそのもので、 `0x1fe0'
     になります。 `argv[1]' の意味は不明です。

     `EB_HOOK_END_KEYWORD' は、フック関数に 1 個の引数を渡します。
     `argv[0]' はエスケープシーケンスのコードそのもので、`0x1fe1' にな
     ります。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。

 - EB_HOOK_NARROW_FONT:
 - EB_HOOK_WIDE_FONT:
     `EB_HOOK_NARROW_FONT' および `EB_HOOK_WIDE_FONT' は、それぞれ半角
     外字と全角外字に対するフックです。

     どちらのフックも、フック関数に渡す `argc' は 1 です。 `argv[0]'
     は、外字の文字番号を表します。

     フック関数を登録していない状態では、このフックはテキストデータに何
     も 書き込みませんが、`eb_initialize_hookset()' で `EB_Hook' オブジ
     ェクトを初期化すると、フック関数として
     `eb_hook_narrow_character_text()' および
     `eb_hook_wide_character_text()' が自動的に登録されます。

 - EB_HOOK_ISO8859_1:
     `EB_HOOK_ISO8859_1' は、ISO 8859-1 (ラテン文字 1) 文字に対するフ
     ックです。

     このフックが、フック関数に渡す `argc' は 1 です。 `argv[0]' は、
     ISO 8859-1 の文字番号を表します。

     フック関数を登録していない状態では、`argv[0]' の値をそのままテキ
     ストデータに書き込みます。 つまり、文字はそのまま ISO 8859-1 とし
     て、1 バイト書き込まれます。

     このフックが利用されるのは、処理中の書籍の文字コードが
     `EB_CHARCODE_ISO8859_1' の場合だけです。

 - EB_HOOK_NARROW_JISX0208:
 - EB_HOOK_WIDE_JISX0208:
     `EB_HOOK_NARROW_JISX0208' と `EB_HOOK_WIDE_JISX0208' は、 半角およ
     び全角の JIS X 0208 (日本語のかな漢字) 文字に対するフックです。

     どちらのフックも、フック関数に渡す `argc' は 1 です。 `argv[0]'
     は、JIS X 0208 の文字を日本語 EUC で表現したときの文字番号を表し
     ます。

     フック関数を登録していない状態では、`argv[0]' の値をそのままテキ
     ストデータに書き込みます。 つまり、文字はそのまま日本語 EUC
     として、2 バイト書き込まれます。

     このフックが利用されるのは、 処理中の書籍の文字コードが
     `EB_CHARCODE_JISX0208' か `EB_CHARCODE_JISX0208_GB2312' の場合だけ
     です。

 - EB_HOOK_GB2312:
     `EB_HOOK_GB2312' は、GB 2312 (中国語の簡体字) 文字に対するフック
     です。

     このフックが、フック関数に渡す `argc' は 1 です。 `argv[0]' は、 GB
     2312 の文字を中国語 EUC で表現したときの文字番号を表します。

     フック関数を登録していない状態では、`argv[0]' の値をそのままテキ
     ストデータに書き込みます。 つまり、文字はそのまま中国語 EUC
     として、2 バイト書き込まれます。

     このフックが利用されるのは、処理中の書籍の文字コードが
     `EB_CHARCODE_JISX0208_GB2312' の場合だけです。

 - EB_HOOK_BEGIN_MONO_GRAPHIC:
 - EB_HOOK_END_MONO_GRAPHIC:
     `EB_HOOK_BEGIN_MONO_GRAPHIC' および `EB_HOOK_END_MONO_GRAPIHC'
     は、モノクロ図版の参照開始と終了を表すエスケープシーケンスに対する
     フックです。

     フック `EB_HOOK_BEGIN_MONO_GRAPHIC' が、フック関数に渡す `argc' は
     4 です。 `argv[0]' はエスケープシーケンスのコードそのもので、
     `0x1f32' か `0x1f44' のいずれかになります。 `argv[2]' と `argv[3]'
     は、図版の高さと幅 (ピクセル数) を意味します。 ただし、電子ブック
     のモノクロ図版 (最初の引数が `0x1f32' の場合) には、図版の高さと幅
     の情報が欠けているので、値はどちらも 0 になります。 `argv[1]' の意
     味は不明です。

     `EB_HOOK_END_MONO_GRAPHIC' が、フック関数に渡す `argc' は 3 です。
     `argv[0]' は、エスケープシーケンスのコードそのものです。
     `EB_HOOK_BEGIN_MONO_GRAPHIC' の `argv[0]' が `0x1f32' なら、
     `EB_HOOK_END_MONO_GRAPHIC' の `argv[0]' は `0x1f52' になり、
     `0x1f44' なら `0x1f64' になります。 `argv[1]' と `argv[2]' は、図
     版データのページ番号とオフセットです。 これは、`EB_Position' オブ
     ジェクト (*note [検索] データ型の詳細 : Search Data Types.)  の
     `page' および `offset' メンバの値に相当します。

     図版データの取り出し方については、*note モノクロ図版 : Monochrome
     Image.  を参照してください。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。

 - EB_HOOK_BEGIN_GRAY_GRAPHIC:
 - EB_HOOK_END_GRAY_GRAPHIC:
     これらのフック名称は、グレースケール図版のために予約されていますが、
     EB ライブラリ 4.0 ではまだ対応していません。

 - EB_HOOK_BEGIN_COLOR_BMP:
 - EB_HOOK_BEGIN_COLOR_JPEG:
 - EB_HOOK_END_COLOR_GRAPHIC:
     `EB_HOOK_BEGIN_COLOR_BMP' と `EB_HOOK_COLOR_JPEG' は、 それぞれ
     BMP 形式と JPEG 形式のカラー図版の参照開始を表すエスケープシーケ
     ンスに対するフックです。 参照開始のフックは BMP と JPEG とでフック
     が分かれていますが、終了のフックは共通で、
     `EB_HOOK_END_COLOR_GRAPIHC' になります。

     フック `EB_HOOK_BEGIN_COLOR_BMP' と `EB_HOOK_COLOR_JPEG' が、 フッ
     ク関数に渡す `argc' は 4 です。 `argv[0]' はエスケープシーケンスの
     コードそのもので、 `0x1f4d' になります。 `argv[2]' と `argv[3]'
     は、図版の幅と高さ (ピクセル数) を意味します。 `argv[1]' の意味は
     不明です。

     フック `EB_HOOK_END_COLOR_BMP' が、フック関数に渡す `argc' は 3 で
     す。 `argv[0]' はエスケープシーケンスのコードそのもので、`0x1f6d'
     に なります。 `argv[1]' と `argv[2]' は、図版データのページ番号と
     オフセットです。 これは、`EB_Position' オブジェクト (*note [検索]
     データ型の詳細: Search Data Types.)  の `page' および `offset' メ
     ンバの値に相当します。

     図版データの取り出し方については、*note カラー図版: Color Image.
     を参照してください。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。

 - EB_HOOK_BEGIN_IN_COLOR_BMP:
 - EB_HOOK_BEGIN_IN_COLOR_JPEG:
 - EB_HOOK_END_IN_COLOR_GRAPHIC:
     `EB_HOOK_BEGIN_IN_COLOR_BMP' と `EB_HOOK_IN_COLOR_JPEG' は、 それ
     ぞれ BMP 形式と JPEG 形式のインラインカラー図版の参照開始を表すエ
     スケープシーケンスに対するフックです。 参照開始のフックは BMP と
     JPEG とでフックが分かれていますが、終了のフックは共通で、
     `EB_HOOK_END_IN_COLOR_GRAPIHC' になります。

     フック `EB_HOOK_BEGIN_IN_COLOR_BMP' と `EB_HOOK_IN_COLOR_JPEG'
     が、フック関数に渡す `argc' は 4 です。 `argv[0]' はエスケープシー
     ケンスのコードそのもので、 `0x1f3c' になります。 `argv[2]' と
     `argv[3]' は、図版の幅と高さ (ピクセル数) を意味します。
     `argv[1]' の意味は不明です。

     フック `EB_HOOK_END_IN_COLOR_BMP' が、フック関数に渡す `argc' は 3
     です。 `argv[0]' はエスケープシーケンスのコードそのもので、 `0x1f5c'
     になります。 `argv[1]' と `argv[2]' は、図版データのページ番号とオ
     フセットです。 これは、`EB_Position' オブジェクト (*note [検索]
     データ型の詳細: Search Data Types.)  の `page' および `offset' メ
     ンバの値に相当します。

     図版データの取り出し方については、*note カラー図版: Color Image.
     を参照してください。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。

 - EB_HOOK_BEGIN_WAVE:
 - EB_HOOK_END_WAVE:
     `EB_HOOK_BEGIN_WAVE' および `EB_HOOK_END_WAVE' は、 WAVE (PCM) 形
     式の音声データの参照開始と終了を表すエスケープシーケンスに対する
     フックです。

     フック `EB_HOOK_BEGIN_WAVE' が、フック関数に渡す `argc' は 6
     です。 `argv[0]' はエスケープシーケンスのコードそのもので、 `0x1f4a'
     になります。 `argv[2]' と `argv[3]' は音声データの開始位置のページ
     番号とオフセット、 `argv[4]' と `argv[5]'
     は終了位置のページ番号とオフセットをそれぞれ表します。 `argv[1]'
     の意味は不明です。

     `EB_HOOK_END_WAVE' が、フック関数に渡す `argc' は 1 です。
     `argv[0]' はエスケープシーケンスのコードそのもので、`0x1f6a' にな
     ります。

     音声データの取り出し方については、*note WAVE 音声: WAVE Sound. を
     参照して下さい。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。

 - EB_HOOK_BEGIN_MPEG:
 - EB_HOOK_END_MPEG:
     `EB_HOOK_BEGIN_MPEG' および `EB_HOOK_END_MPEG' は、MPEG 形式の動
     画データの参照開始と終了を表すエスケープシーケンスに対するフック
     です。

     フック `EB_HOOK_BEGIN_MPEG' が、フック関数に渡す `argc' は 6
     です。 `argv[0]' はエスケープシーケンスのコードそのもので、 `0x1f39'
     になります。 `argv[2]' 〜 `argv[5]' は、動画データのファイル名をエ
     ンコードした数値列になります。 `argv[1]' の意味は不明です。

     `EB_HOOK_END_MPEG' が、フック関数に渡す `argc' は 1 です。
     `argv[0]' はエスケープシーケンスのコードそのもので、`0x1f59' にな
     ります。

     動画データの取り出し方については、*note MPEG 動画: MPEG Movie. を
     参照して下さい。

     フック関数を登録していない状態では、これらのフックはテキストデータ
     に何も書き込みません。


File: eb-ja.info,  Node: Hookset Access Functions,  Next: Builtin Hook Functions,  Prev: Hook Code List,  Up: Text Data

フックセット操作関数の詳細
==========================

   この節で説明している関数を使うには、次のようにヘッダファイルを読み込
んで下さい。

     #include <eb/text.h>

 - 機能: void eb_initialize_hookset (EB_Hookset *HOOKSET)
     関数 `initialize_hookset()' は、HOOKSET の指す `EB_Hookset' オブジ
     ェクトを初期化します。 `EB_Hookiset' オブジェクトに対して EB ライ
     ブラリの他の関数を呼ぶ前に、 必ずそのオブジェクトを初期化しなくて
     はなりません。 初期化していないオブジェクトに対して、EB ライブラリ
     の他の関数を呼んだ場合の動作は未定義です。 また、すでに初期化した
     オブジェクトに対して、再度 `eb_initialize_hookset()' を呼んではい
     けません。 呼んだ場合の動作は未定義です。

     この関数は、各フックの初期値を次のようにセットします。

     フック                             フック関数
     `EB_HOOK_NARROW_JISX0208'          `eb_hook_euc_to_ascii()'
     `EB_HOOK_NARROW_FONT'              `eb_hook_narrow_character_text()'
     `EB_HOOK_WIDE_FONT'                `eb_hook_wide_character_text()'
     `EB_HOOK_NEWLINE'                  `eb_hook_newline()'
     上記以外のフック                   `NULL' (フック関数なし)

 - 機能: EB_Error_Code eb_finalize_hookset (EB_Hookset *HOOKSET)
     関数 `eb_finalize_hookset()' は、HOOKSET が指す `EB_Hooksest' オブ
     ジェクトの後始末を行います。

     オブジェクトが割り当てて管理していたメモリは、すべて解放されます。
     すべてのフックには、フック関数として `NULL' がセットされます。

     後始末をしたオブジェクトに対して `eb_set_hook()', `eb_set_hooks()'
     を呼ぶことで、オブジェクトを再利用することができます。

 - 機能 : EB_Error_Code eb_set_hook (EB_Hookset *HOOKSET, const EB_Hook
          *HOOK)
     関数 `eb_set_hook()' は、HOOKSET が指す `EB_Hooksest' オブジェクト
     に、フック関数を一つ登録します。 登録するフックの種類とフック関数
     は、HOOK で指定します。

     同じフックコードに複数回フック関数を登録しても、有効になるのは最後
     に 登録したものだけですので、注意して下さい。 フック関数として
     `NULL' を指定すると、登録されているフックが解除されます。

     成功すると、この関数は `EB_SUCCESS' を返します。 失敗すると、原因
     を示すエラーコードを返します。

 - 機能 : EB_Error_Code eb_set_hooks (EB_Hookset *HOOKSET, const EB_Hook
          *HOOKS)
     この関数は `eb_set_hook()' に似ていますが、任意の個数のフック関数
     を一度に登録できる点が異なります。

     登録するフックの種類とフック関数は、 HOOKS で指定します。 HOOKS は
     `EB_Hook' オブジェクトの配列 (の先頭) を指していなければなりませ
     ん。 また、この配列の末尾には、フックコード `EB_HOOK_NULL' をセッ
     ト した `EB_Hook' オブジェクトを配列要素として置く必要があります。

     `eb_set_hooks()' は、配列の先頭から順番に、指定されたフックコード
     に対してフック関数を登録していきます。 エラーが発生すると、残りの
     フックの登録はせずに、原因を示すエラーコードをただちに返します。
     すべてのフック関数の登録に成功すると、`EB_SUCCESS' を返します。


File: eb-ja.info,  Node: Builtin Hook Functions,  Next: Text Data Functions,  Prev: Hookset Access Functions,  Up: Text Data

組み込みフック関数の詳細
========================

   EB ライブラリは、基本的なフック関数をいくつか用意しています。 本節で
は、これらのフック関数についての仕様を解説します。

   この節で説明している関数を使うには、次のようにヘッダファイルを読み込
んで下さい。

     #include <eb/text.h>

   いずれのフック関数も、引数 APPENDIX と CONTAINER に `NULL' を渡され
ても、動作に支障はないようになっています。

 - 機能 : EB_Error_Code eb_hook_euc_to_ascii (EB_Book *BOOK, EB_Appendix
          *APPENDIX, void *CONTAINER, EB_Hook_Code CODE, int ARGC,
          const unsigned int *ARGV)
     `eb_hook_euc_to_ascii()' は、フックコード
     `EB_HOOK_NARROW_JISX0208' (半角 JIS X 0208 文字) のためのフック関
     数 です。

     `EB_Hookset' オブジェクトを関数 `eb_initialiez_hookset()' で初期
     化すると、この関数が自動的に登録されます。

     このフック関数は、`argv[0]' として渡された JIS X 0208 の文字 (エン
     コーディングは日本語 EUC) を調べ、対応する ASCII 文字が存在すれば
     その ASCII 文字をテキストデータとして書き込み、なければ JIS X 0208
     の文字をそのまま書き込みます。

     常に `EB_SUCCESS' を返します。

 - 機能 : EB_Error_Code eb_hook_narrow_character_text (EB_Book *BOOK,
          EB_Appendix *APPENDIX, void *CONTAINER, EB_Hook_Code CODE,
          int ARGC, const unsigned int *ARGV)
 - 機能 : EB_Error_Code eb_hook_wide_character_text (EB_Book *BOOK,
          EB_Appendix *APPENDIX, void *CONTAINER, EB_Hook_Code CODE,
          int ARGC, const unsigned int *ARGV)
     `eb_hook_narrow_character_text()' は、フックコード
     `EB_HOOK_NARROW_FONT' (半角外字) のためのフック関数です。 同様に
     `eb_hook_wide_character_text()' は、フックコード
     `EB_HOOK_WIDE_FONT' (全角外字) のためのフック関数です。

     `EB_Hookset' オブジェクトを関数 `eb_initialiez_hookset()' で初期
     化すると、これらの関数が自動的に登録されます。

     この関数は、APPENDIX の選択中している副本が、`argv[0]' として渡さ
     れた外字の代替文字列を持っているかどうか調べます。 持っていればそ
     の文字列をテキストデータとして書き込み、持っていなければ `<?>' と
     いう文字列を書き込みます。

     APPENDIX が `NULL' の場合や、付録が副本を選択中でない場合も、 代替
     文字列を持っていないものとして扱います。

     この関数は、常に `EB_SUCCESS' を返します。

 - 機能 : EB_Error_Code eb_hook_newline (EB_Book *BOOK, EB_Appendix
          *APPENDIX, void *CONTAINER, EB_Hook_Code CODE, int ARGC,
          const unsigned int *ARGV)
     `eb_hook_narrow_newline()' は、フックコード `EB_HOOK_NEWLINE' (改
     行) のためのフック関数です。

     `EB_Hookset' オブジェクトを関数 `eb_initialiez_hookset()' で初期
     化すると、これらの関数が自動的に登録されます。

     この関数は、テキストデータに `\n' を書き込みます。 常に
     `EB_SUCCESS' を返します。

 - 機能 : EB_Error_Code eb_hook_empty (EB_Book *BOOK, EB_Appendix
          *APPENDIX, void *CONTAINER, EB_Hook_Code CODE, int ARGC,
          const unsigned int *ARGV)
     `eb_hook_empty()' は、何もしないフック関数です。 常に `EB_SUCCESS'
     を返します。


File: eb-ja.info,  Node: Text Data Functions,  Prev: Builtin Hook Functions,  Up: Text Data

テキストデータ操作関数の詳細
============================

   この節で説明している関数を使うには、次のようにヘッダファイルを読み込
んで下さい。

     #include <eb/text.h>

 - 機能: int eb_have_text (EB_Book *BOOK)
 - 機能: int eb_have_menu (EB_Book *BOOK)
 - 機能: int eb_have_copyright (EB_Book *BOOK)
     関数 `eb_have_text()' は、BOOK の選択している副本が、本文を持って
     いるかどうかを調べます。 同様に、`eb_have_menu()' はメニューを持っ
     ているかどうか、 `eb_have_copyright()' は著作権表示を持っているか
     どうか調べます。

     いずれの関数も、持っていれば 1 を返し、持っていなければ 0 を返しま
     す。 BOOK が副本を選択していない場合も 0 を返します。

 - 機能: EB_Error_Code eb_text (EB_Book *BOOK, EB_Position *POSITION)
 - 機能: EB_Error_Code eb_menu (EB_Book *BOOK, EB_Position *POSITION)
 - 機能 : EB_Error_Code eb_copyright (EB_Book *BOOK, EB_Position
          *POSITION)
     関数 `eb_text()' は、 BOOK が選択している副本の本文の開始位置を
     POSITION の指す領域に書き込みます。 同様に、`eb_menu()' はメニュー
     の開始位置を、 `eb_have_copyright()' は著作権表示の開始位置を書き
     込みます。

     成功すると、これらの関数は `EB_SUCCESS' を返します。 失敗すると、
     POSITION に必ずシークが失敗する位置を書き込んで、 原因を示すエラー
     コードを返します。

     あらかじめ、BOOK 内のいずれかの副本が選択されていなくてはなりませ
     ん。 BOOK が副本を選択していなければ、`EB_ERR_NO_CUR_SUB' を返しま
     す。 選択中の副本が、対象となるテキストデータを持っていなければ、
     `EB_ERR_NO_SUCH_SEARCH' を返します。

 - 機能 : EB_Error_Code eb_seek_text (EB_Book *BOOK, const EB_Position
          *POSITION)
     関数 `eb_seek_text()' は、BOOK が選択している副本のテキストデータ
     ファイルをシークします。 シーク位置は POSITION で指定します。 この
     とき、 POSITION は常にファイルの先頭からの位置として解釈されます。
     (相対位置へのシーク機能は、EB ライブラリにはありません。)

     シークを行うと、それまでに行った読み込みの状態記録がリセットされま
     す。 `eb_read_text()', `eb_read_heading()', `eb_read_rawtext()' を
     用いてテキストデータを読み込むには、前もってこの関数を呼び出して
     おく必要があります。

     成功すると、この関数は `EB_SUCCESS' を返します。 失敗すると、原因
     を示すエラーコードを返します。

     あらかじめ、BOOK 内のいずれかの副本が選択されていなくてはなりませ
     ん。 BOOK が副本を選択していなければ、`EB_ERR_NO_CUR_SUB' を返しま
     す。 選択中の副本にテキストデータが存在しないときは、
     `EB_ERR_NO_TEXT' を返します。

     なお、書籍によっては、テキストデータを収めたファイルには他のデータ
     も 一緒に格納されていることがありますが、テキスト以外のデータにア
     クセスしても、テキストデータの現在位置、読み込みに関する状態記録
     は変化しません。

 - 機能 : EB_Error_Code eb_tell_text (EB_Book *BOOK, EB_Position
          *POSITION)
     関数 `eb_seek_text()' は、BOOK が選択している副本のテキストデータ
     ファイルの現在のアクセス位置を返します。

     成功すると、 POSITION の指す領域に現在のアクセス位置を書き込み、
     `EB_SUCCESS' を返します。 失敗すると、シークが必ず失敗する位置を書
     き込み、原因を示すエラーコードを返します。

     あらかじめ、BOOK 内のいずれかの副本が選択されていなくてはなりませ
     ん。 BOOK が副本を選択していなければ、`EB_ERR_NO_CUR_SUB' を返しま
     す。 選択中の副本にテキストデータが存在しないときは、
     `EB_ERR_NO_TEXT' を返します。

 - 機能 : EB_Error_Code eb_read_text (EB_Book *BOOK, EB_Appendix
          *APPENDIX, EB_Hookset *HOOKSET, void *CONTAINER, size_t
          TEXT_MAX_LENGTH, char *TEXT, ssize_t *TEXT_LENGTH)
 - 機能 : EB_Error_Code eb_read_heading (EB_Book *BOOK, EB_Appendix
          *APPENDIX, EB_Hookset *HOOKSET, void *CONTAINER, size_t
          TEXT_MAX_LENGTH, char *TEXT, ssize_t *TEXT_LENGTH)
     関数 `eb_read_text()' と `eb_read_heading()' は、BOOK が選択してい
     る副本のテキストデータファイルの現在のアクセス位置からデータを読
     み込みます。 `eb_read_heading()' は見出しの読み込みに用い、
     `eb_read_text()' はそれ以外のテキストデータの読み込みに用います。

     読み込まれたテキストデータは、必要に応じて文字コードの変換 (*note
     文字コード: Character Code.) が行われた後に、HOOKSET の指すフック
     セットにしたがって加工されます。 HOOKSET が `NULL' のときは、代わ
     りに EB ライブラリ側で用意している "標準のフックセット (default
     hookset)" が用いられます。 このフックセットは、
     `eb_initialize_hookset()' によって初期化しただけのフックセットと
     等価です。

     フックセットによって加工された後に、テキストデータは TEXT の指す
     領域に書き込まれ、書き込んだバイト数が TEXT_LENGTH の指す領域に書
     き込まれます。 TEXT はナル文字で終端されますが、TEXT_LENGTH にはナ
     ル文字の分は勘定に入れません。 テキストデータは、TEXT_MAX_LENGTH
     で指定されたバイト数を超えて書き込むことはありません。 ただし、
     TEXT_MAX_LENGTH にもナル文字の分は勘定に入っていませんので、TEXT
     は TEXT_MAX_LENGTH + 1 バイト分のデータを格納できる大きさが必要で
     す。

     どちらの関数も、成功すれば `EB_SUCCESS' を返し、失敗すれば
     TEXT_LENGTH の指す領域に 0 を書き込んで原因を示すエラーコードを返
     します。

     あらかじめ、BOOK 内のいずれかの副本が選択されていなくてはなりませ
     ん。 BOOK が副本を選択していなければ、`EB_ERR_NO_CUR_SUB' を返しま
     す。

     また、`eb_read_text()' と `eb_read_heading()' を呼び出すには、 あ
     らかじめ `eb_seek_text()' の呼び出しを成功させ、テキストデータの
     アクセス位置がセットされた状態にしておかなくてはなりません。 シー
     クをせずに呼び出すと、`EB_ERR_NO_PREV_SEEK' を返します。

     逆に一度シークすれば、区切りコードが検出されるまでの間なら、関数を
     繰り返し呼ぶことでテキストデータの続きを読み込むことができます。
     区切りコードが検出されると、関数を呼び出しても読み込みは行われませ
     ん。 その場合でも、他にエラーが発生しなければ `EB_SUCCESS'
     が返り、 TEXT には空文字列が書き込まれます。

     ただし、一度 `eb_read_text()'
     を呼び出してテキストデータを読み込み始めたら、繰り返し呼び出す際も、
     `eb_read_text()' を使わなければなりません。 途中から
     `eb_read_heading()' および後述の `eb_read_rawtext()' に切り替えて
     呼び出すと `EB_ERR_DIFF_CONTENT' エラーが返ります。 関数
     `eb_read_heading()' についても同様です。 この制限は、再度
     `eb_seek_text()' を呼び出すか、 `eb_set_subbook()' で副本を選択し
     直すまで続きます。

     APPENDIX が `NULL' ではなく、区切りコードの情報を持った副本を選択
     中であれば、本文の区切りコードとしてその値を使用します。 それ以外
     の場合は、`eb_read_text()' が区切りコードを自動判別を試みます。
     ただし、この判定は完璧なものではないので、書籍によっては変な位置で
     本文が切れてしまうかも知れません。 (本文以外のテキストデータに関
     しては、このような問題は起きません。)

     引数 CONTAINER は、アプリケーションプログラムからフック関数にデー
     タ を渡すためのものです。 `eb_read_text()', `eb_read_heading()' で
     は、直接この引数の値を参照することはありません。

     引数 APPENDIX, CONTAINER は、そのままフック関数に渡されます。 これ
     らの引数は `NULL' でも構いません。 (呼び出されるフック関数で支障が
     なければ。)

     なお、フック関数や `eb_read_text()', `eb_read_heading()' 自身が文
     字ないしエスケープシーケンス一個分に対するデータを書き込もうとし
     たときに、TEXT に十分な空き領域がないということが起こり得ます。 そ
     の場合、関数は途中まで TEXT に書き込むことはせずに、いったん処理
     を終えて戻ります。 したがって、マルチバイト文字のデータが途中で切
     れたりすることはありません。

     書き込めなかった分は、当然ながら TEXT_LENGTH
     の勘定には入りません。 書き込めなかったデータは BOOK 内部に保存さ
     れているので、もう一度 `eb_read_text()', `eb_read_heading()' を呼
     び出すと、前回の呼び出しで書き込めなかったデータがまず TEXT の先
     頭に書き込まれます。 書き込んだデータは TEXT_LENGTH の勘定に入りま
     す。

     ただし、`book' が保存しているデータの長さが MAX_TEXT_LENGTH を超
     えていると、何も書き込まずに関数は終了します。 このとき、書き込め
     なかったデータは引き続き保存されます。 つまり、`text_max_length'
     があまりに小さく、かつ保持しているデータのほうが長いと、何度呼び
     出しても `text' への書き込みが進みませんので、 注意が必要です。

     `eb_seek_text()' を呼び出すか、`eb_set_subbook()' で副本を選択し
     直すと、保存していたデータは破棄されます。

 - 機能 : EB_Error_Code eb_read_rawtext (EB_Book *BOOK, size_t
          TEXT_MAX_LENGTH, char *TEXT, ssize_t *TEXT_LENGTH)
     関数 `eb_read_rawtext()' は、BOOK が選択している副本のテキストデ
     ータファイルの現在のアクセス位置からデータを読み込みます。

     `eb_read_text()' と似ていますが、この関数はフックセットによるデー
     タ の加工や文字コードの変換を一切行わず、データを内部表現のまま返
     します。 読み込むテキストデータの種類は、何であっても構いません。

     読み込んだテキストデータは TEXT
     の指す領域に書き込まれ、書き込んだバイト数が TEXT_LENGTH の指す領
     域に書き込まれます。 テキストデータは、TEXT_MAX_LENGTH で指定され
     たバイト数を超えて書き込むことはありません。 ただし、
     `eb_read_text()' と異なり、TEXT はナル文字で終端されません。 マル
     チバイト文字やエスケープシーケンスの途中で TEXT の残り領域が足り
     なくなった場合も、途中までは書き込みます。

     処理が成功すれば `EB_SUCCESS' を返し、失敗すれば TEXT_LENGTH の指
     す領域に 0 を書き込んで原因を示すエラーコードを返します。

     あらかじめ、BOOK 内のいずれかの副本が選択されていなくてはなりませ
     ん。 BOOK が副本を選択していなければ、`EB_ERR_NO_CUR_SUB' を返しま
     す。

     また、この関数を呼び出すには、あらかじめ `eb_seek_text()' の呼び出
     し を成功させ、テキストデータのアクセス位置がセットされた状態にし
     て おかなくてはなりません。 シークをせずに呼び出すと、
     `EB_ERR_NO_PREV_SEEK' を返します。

     この関数は、繰り返し呼び出すことで、前回読み込んだテキストデータの
     続きを読み込むことができます。 ただし、区切りコードの検出を行いま
     せんので、ひたすら呼び出しを続けると、 テキストデータファイルの末
     尾まで行ってしまいます。

     一度 `eb_read_rawtext()' を呼び出してテキストデータを読み込み始め
     たら、繰り返し呼び出す際も、`eb_read_rawtext()' を使わなければな
     りません。 途中から、`eb_read_text()' や `eb_read_text()' に切り替
     えると、 `EB_ERR_DIFF_CONTENT' エラーが返ります。 この制限は、再度
     `eb_seek_text()' を呼び出すか、 `eb_set_subbook()' で副本を選択し
     直すまで続きます。

 - 機能: int eb_is_text_stopped (EB_Book *BOOK)
     関数 `eb_is_text_stopped()' は、最後に読み込んだテキストデータが
     末尾に達したかどうかを判定します。

     BOOK が選択中の副本で、最後に `eb_read_text()' または
     `eb_read_heading()'
     でテキストデータを読み込んだ際に、区切りコードを検出したか、テキス
     トデータの末尾に達して読み込みを終えていれれば、この関数は 1 を返
     します。 それ以外のときは、0 を返します。

     BOOK が副本を選択していない場合や、選択中の副本にテキストデータが
     存在しない場合も 0 が返ります。

     `eb_read_text()' または `eb_read_heading()' でテキストデータを読
     み込んでいない場合も、同様に 0 が返ります。 テキストデータを読み込
     んだ後であっても、テキストデータの読み込みに関する状態記録をリセ
     ットする関数 (eb_read_text() の項を参照) を呼んでしまうと、 読み込
     んでいないと見なされますので、注意して下さい。

     通常はこの関数を使わなくても、 `eb_read_text()' や
     `eb_read_heading()' が 0 を返したら、テキストデータの末尾に達した
     とみなして差し支えないでしょう。 ただしその際は、引数
     `text_max_length' の値を十分大きく取って下さい。


 - 機能: EB_Error_Code eb_write_text_byte1 (EB_Book *BOOK, int BYTE1)
 - 機能 : EB_Error_Code eb_write_text_byte2 (EB_Book *BOOK, int BYTE1,
          int BYTE2)
 - 機能 : EB_Error_Code eb_write_text_string (EB_Book *BOOK, const char
          *STRING)
 - 機能 : EB_Error_Code eb_write_text (EB_Book *BOOK, const char
          *STREAM, size_t STREAM_LENGTH)
     これらの関数は、いずれもフック関数の中から、テキストデータを書き込
     む ために用います。
     書き込むデータの種類によって、使い分けて下さい。

     `eb_write_text_byte1()' は、BYTE1 で指定した 1 バイトの値を書き込
     みます。 `eb_write_text_byte2()' は、BYTE1, BYTE2 で指定した 2 バ
     イトを書き込みます。 `eb_write_text_string()' は、STRING で指定し
     た文字列を書き込みます。 `eb_write_text()' は、STREAM から始まる
     長さ STREAM_LENGTH バイトのバイト列を書き込みます。

     どの関数も、成功すると `EB_SUCCESS' を返し、失敗すると原因を示す
     エラーコードを返します。

     最終的に、書き込んだテキストデータは、フック関数の呼び出し元である
     `eb_read_text()', `eb_read_heading()' からアプリケーションプログ
     ラムに渡されます。

     フック関数として呼び出されていないときに、これらの関数を呼び出した
     場合の動作は未定義です。

 - 機能: const char * eb_current_candidate (EB_Book *BOOK)
     関数 `eb_current_candidate()' は、アクセス中のテキストデータの現
     在位置に書かれている、複合検索の候補となる語を返します。

     返す文字列の長さは、最長で `EB_MAX_WORD_LENGTH' バイトになります。
     ただし、この長さにナル文字は含みません。

     この関数は非常に特殊で、複合検索の候補となる語の終了を意味するエ
     スケープシーケンスへのフックである `EB_HOOK_END_CANDIDATE_LEAF' お
     よび `EB_HOOK_END_CANDIDATE_GROUP' に対するフック関数の中でのみ呼
     び出すことができます。 それ以外の場所で呼び出したときの動作は、未
     定義です。

     この関数の呼び出し方ですが、フック関数に渡ってきた `EB_Book' オブ
     ジェクト (へのポインタ) を、そのままこの関数に引数として渡してや
     ります。

     BOOK の文字コード (*note [CD-ROM 書籍と `EB_Book' オブジェクト] デ
     ータ型の詳細: EB_Book Data Types.)  が `EB_CHARCODE_ISO8859_1' な
     ら、関数の返す文字列は ISO 8859-1 になり、それ以外の文字コードの場
     合は日本語 EUC になります。 関数の返す文字列は、他のフックによる加
     工処理の影響を受けません。 文字コードの変換を行う以外は、内部デー
     タをそのまま返します。

     なお、この関数が返した文字列を参照できるのは、フック関数から戻るま
     での間だけですので、注意して下さい。

 - 機能 : EB_Error_Code eb_forward_text (EB_Book *BOOK, EB_Appendix
          *APPENDIX)
 - 機能 : EB_Error_Code eb_backward_text (EB_Book *BOOK, EB_Appendix
          *APPENDIX)
     関数 `eb_forward_text()' と `eb_backward_text()' は、 BOOK が選択
     している副本の本文のアクセス位置を前後に移動させ、 本文の区切りコ
     ードを単位とした頭出しを行います。 ちょうど、音楽 CD の曲の頭出し
     と同じです。

     `eb_forward_text()'
     は本文の末尾方向に向かってアクセス位置を進め、 `eb_backward_text()'
     は先頭方向に向かってアクセス位置を戻します。

     `eb_forward_text()' の呼び出しでは、アクセス位置は必ず次の語の説
     明の開始位置まで移動します。 それに対して `eb_backward_text()' の
     呼び出しでは、移動先が状態によって異なります。 もし、現在のアクセ
     ス位置がその単語の説明の先頭にあるときは、 `eb_backward_text()' の
     呼び出しによって、一つ前の単語の説明の先頭にアクセス位置が移動し
     ます。 アクセス位置が単語の説明の途中や末尾にあるときは、その単語
     の説明の先頭に移動します。

     この関数は、成功すると `EB_SUCCESS' を返し、失敗すると原因を示す
     エラーコードを返します。

     あらかじめ、BOOK 内のいずれかの副本が選択されていなくてはなりませ
     ん。 BOOK が副本を選択していなければ、`EB_ERR_NO_CUR_SUB' を返しま
     す。

     加えて、これらの関数を呼び出すには、あらかじめ `eb_seek_text()' か
     `eb_read_text()' を呼び出しが成功していないといけません。
     (`eb_read_text()' の呼び出しを成功させるには、さらに前もって
     `eb_seek_text()' の呼び出しを成功させることが条件となります。)

     `eb_read_text()' ではなく、 `eb_read_heading()' や
     `eb_read_rawtext()' の呼び出しに成功した後でこの関数を呼び出すと、
     `EB_ERR_DIFF_CONTENT' を返します。 また、前もって `eb_seek_text()'
     でシークせずにこの関数を呼び出すと、 `EB_ERR_NO_PREV_SEEK' を返し
     ます。

     本文データの末尾や先頭に達してしまって、その方向にもう本文がないと
     きは、 `EB_ERR_END_OF_CONTENT' を返します。

     APPENDIX が `NULL' ではなく、区切りコードの情報を持った副本を選択
     中であれば、本文の区切りコードとしてその値を使用します。 それ以外
     の場合は、`eb_read_text()' と同じ方法で区切りコードの自動判別を試
     みます。

     アクセス位置上にあるのがメニューや著作権表示のように、本文以外の
     テキストデータであっても、構いません。 ただし、本文以外のテキスト
     データの内部には、頭出し位置が一箇所しかありませんので、この関数
     が役に立つ状況はほとんどありません。

     (メニューでは、個々の階層のメニューデータが、それぞれ独立したテキ
     ストデータになっているため、頭出しを行っても前後のメニューデータへ
     は 移動できません。 複合検索の候補一覧も同様です。)


File: eb-ja.info,  Node: Local Character,  Next: Binary Data,  Prev: Text Data,  Up: Top

外字
****

文字コードに収録されていない、私的に定義した文字のことを、俗に「外字」
と言います。 外字として定義した個々の文字を識別するために、文字コードに
収録された文字とは重複しない位置に、各文字の文字番号に割り振るのが普通
です。 (割り当てる文字番号の詳細については、*note 文字コード : Character
Code.。)

   市販の電子ブック、EPWING でも、ほとんどが外字を使っています。 外字の
定義状況は書籍同士でバラバラで、まったく統一感はありません。 つまり、同
じ文字番号を使っていても、定義されている外字は書籍によって違います。
外字は副本毎に定義することが可能ですが、一つの CD-ROM 書籍内でも副本に
よって定義が異なることも珍しくありません。 副本によっては、数百から数千
の外字を定義していることもあります。

   CD-ROM 書籍では、定義した外字の字形データ (つまりフォント) を用意し
て います。 フォントはビットマップデータであり、書籍によっては大きさの
異なる数種類のフォントを用意しています。

   逆に言えば、外字に対して提供されるデータは、フォントだけです。 ある
文字番号を割り当てられた外字が、漢字なのか、発音記号なのか、そういった
補助的な情報は用意されていません。 アプリケーションプログラムが外字をサ
ポートするためには、外字のフォントをそのまま表示する以外に方法はないで
しょう。

* Menu:

* Narrow & Wide Font::          半角外字と全角外字
* Font Size and Font Code::     外字の大きさと外字コード
* Current Font Height::         選択中の外字フォントの高さ
* Get Font::                    外字フォントの取り出し
* Convert Font::                外字フォントの変換
* Local Character in Text::     テキスト中の外字
* Font Data Types::             データ型の詳細
* Font Constants::              定数の詳細
* Font Functions::              関数の詳細
* Font Sample::                 サンプルプログラム


File: eb-ja.info,  Node: Narrow & Wide Font,  Next: Font Size and Font Code,  Prev: Local Character,  Up: Local Character

半角外字と全角外字
==================

   CD-ROM 書籍における外字には、「全角外字」「半角外字」の二種類があり
ます。 全角外字は用意されているフォントの横と縦の長さがおよそ 1:1 にな
っており、 半角外字では 1:2 になっています。

     　　　　　　全角外字　　　　　　　　　　半角外字　　
     　　　　（１６×１６）　　　　　　　　（８×１６）
     □□□□□□□□□□□□□□□□　　□□□□□□□□
     □□□□□□□□□□□□□□□□　　□□■■□■□□
     □□□■■■■■■□□□■□□□　　□□□□■□□□
     □□□□□□□□■□■□■□□□　　□□□■■□□□
     □□□□■□□■□□■□■□□□　　□□■□□■□□
     □□□□■□□■■■■■■□□□　　□■□□□■□□
     □□■■■■■□□□■□■□□□　　□□□■□■□□
     □□□□□□□□□□■□■□□□　　□□■□■■□□
     □□□■□□□□□□□□■□□□　　□■□□□■□□
     □□□■□□□□□□□□■□□□　　□■□□□■□□
     □□□■■■■■■■■■■□□□　　□■□□□■□□
     □□□■□□□□□□□□■□□□　　□■□□□■□□
     □□□■□□□□□□□□■□□□　　□■□□□■□□
     □□□■■■■■■■■■■□□□　　□■□□□■□□
     □□□□□□□□□□□□□□□□　　□□■■■□□□
     □□□□□□□□□□□□□□□□　　□□□□□□□□

テキストデータには、半角表示の開始と終了を表すエスケープシーケンスがあ
り (*note テキストデータの内部形式: Text Data Format.)、開始と終了の間
に置かれたものは半角外字、それ以外のところなら全角外字になります。

文字番号は同じでも、字形が全角と半角ではまったく異なることもありますの
で、外字の文字番号だけから、全角と半角のどちらかを判断することはできま
せん。 かならず、前方に半角開始のエスケープシーケンスが出現していたかど
うかという情報に基づいて判断しないといけません。

   ただし、全角か半角かの判定は EB ライブラリ側で行いますので、 アプリ
ケーションプログラムが文脈の解析を行う必要はありません。

   CD-ROM 書籍の副本には、半角外字あるいは全角外字のどちらか一方だけを
定義しているものもありますし、両方とも定義しているものもあります。


File: eb-ja.info,  Node: Font Size and Font Code,  Next: Current Font Height,  Prev: Narrow & Wide Font,  Up: Local Character

外字の大きさと外字コード
========================

各副本には、定義している外字のフォントがビットマップ形式で収録されてい
ます。 フォントの大きさは、縦のピクセル数を基準にすると 16, 24, 30, 48
の 4 種類があり、全角外字、半角外字それぞれのフォントの大きさ (横のピク
セル数×縦のピクセル数) は次の通りになります。

縦のピクセル数                全角全角               半角外字
16                            16x16                  8x16
24                            24x24                  16x24
30                            32x30                  16x30
48                            48x48                  24x48

   ただし、すべての副本でこれら 4 種類のフォントを用意しているわけでは
ありません。 縦が 16 ピクセルのものは必ず用意されていますが、それ以外は
ないことも珍しくありません。 (外字がまったく定義されていなければ、16
ピクセルのフォントも用意されません。)

   EB ライブラリでは、このように縦方向のピクセル数、つまり "フォントの
高さ (font height)" を基準に、外字フォントの大きさを区別しています。
そして、それぞれのフォントの高さ (16, 24, 30, 48) に対して、 "外字コー
ド (font code)" というものを割り当てています。 フォントの高さを指定する
際は、必ずこの外字コードを使います。

縦のピクセル数                       外字コード
16                                   `EB_FONT_16'
24                                   `EB_FONT_24'
30                                   `EB_FONT_30'
48                                   `EB_FONT_48'


File: eb-ja.info,  Node: Current Font Height,  Next: Get Font,  Prev: Font Size and Font Code,  Up: Local Character

選択中の外字フォントの高さ
==========================

   `EB_Book' オブジェクトで選択中の副本が用意している外字フォントの高
さの中から一つ選んで、 "選択中の外字フォントの高さ (current font
height)" として指定することができます。 EB ライブラリで外字のフォント
データ (ビットマップデータ) を取り出すには、 外字フォントの高さをあらか
じめ選択しておく必要があります。

   選択するには、関数 `eb_set_font()' を使います。 以下のプログラムは、
高さ 24 ピクセルのフォントを選択する場合の例です。

     /* `book' が `EB_Book' のオブジェクトで、すでに書籍に結び付け
      * られ、副本を選択中だと仮定しています。*/
     if (eb_set_font(&book, EB_FONT_24) != EB_SUCCESS) {
         printf("eb_set_font_() failed\n");
         return;
     }

   このプログラムでは、高さ 24 ピクセルのフォントを選択中の副本が用意し
て いるものと仮定していますが、実際には用意していない副本も珍しくありま
せん。 もし、副本が高さ 24 ピクセルのフォントを用意していなければ、
`eb_set_font()' は `EB_ERR_NO_SUCH_FONT' を返します。

しかし、外字を選択する前に、前もってその副本が用意しているフォントを知
りたいときもあります。 これには、2 通りの方法があります。

   まず 1 つ目は、選択中の副本が用意しているフォントの高さの一覧を
`eb_font_list()' で取得する方法です。 これは、副本コードの一覧を取得す
る `eb_subbook_list()' と使い方が良く似ています。

     EB_Font_Code font_list[EB_MAX_FONTS];
     int font_count;
     int i;
     
     if (eb_font_list(&book, font_list, &font_count) != EB_SUCCESS) {
         printf("eb_font_list() failed\n");
         return;
     }
     
     for (i = 0; i < font_count; i++) {
         if (font_list[i] == EB_FONT_24)
             printf("this subbook has EB_FONT_24\n");
     }

   2 つ目は、`eb_have_font()' を使うやり方です。 この関数は、特定の高さ
のフォントを、選択中の副本が用意しているかどうか調べることができます。

     if (eb_have_font(&book, EB_FONT_24)) {
         printf("this subbook has EB_FONT_24\n");
     }

   また、選択中の副本が半角外字、全角外字を定義しているかどうかは、それ
ぞれ `eb_have_narrow_font()', `eb_have_wide_font()' を使って調べること
ができます。

     if (eb_have_narrow_font(&book))
         printf("this subbook has narrow font\n");
     if (eb_have_wide_font(&book))
         printf("this subbook has wide font\n");

   なお、あらかじめ副本を選択しておかないと、外字の高さは選択できないの
で 注意して下さい。 `eb_set_subbook()' で選択中の副本を切り替えると、外
字フォントの高さは常に未選択の状態に戻ります。

