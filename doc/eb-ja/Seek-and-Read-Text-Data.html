<html lang="en">
<head>
<title>EB Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="EB Library">
<meta name="generator" content="makeinfo 4.5">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home">
</head>
<body>
<div class="node">
<p>
ノード:<a name="Seek%20and%20Read%20Text%20Data">Seek and Read Text Data</a>,
次:<a rel="next" accesskey="n" href="Text-Data-Format.html#Text%20Data%20Format">Text Data Format</a>,
前:<a rel="previous" accesskey="p" href="Text-Data.html#Text%20Data">Text Data</a>,
上:<a rel="up" accesskey="u" href="Text-Data.html#Text%20Data">Text Data</a>
<hr><br>
</div>

<h3 class="section">テキストデータのシークと読み込み</h3>

   <p>UNIX でプログラムを組んだ経験のある方には、ファイルからデータを読み込む
際に用いる <code>lseek()</code>, <code>read()</code> というシステムコールをご存じの
方も多いでしょう。

   <p>EB ライブラリでも、テキストデータの取得には、<dfn>シーク (seek)</dfn> と
<dfn>読み込み (read)</dfn> という 2 つの操作で行います。
ただし、EB ライブラリではファイルポインタやディスクリプタはなく、
<code>EB_Book</code> オブジェクトを通じてシークや読み込みの操作を行います。

   <p>また、シーク時に指定する位置も <code>off_t</code> 型ではなく、
<code>EB_Position</code> 型 (see <a href="Search-Data-Types.html#Search%20Data%20Types">[検索] データ型の詳細</a>)
のオブジェクトを用います。
たとえば、本文の先頭位置は、<code>eb_text()</code> という関数を使って次のように
取得できますが、このときも位置データは <code>EB_Position</code> 型オブジェクト
に書き込まれます。

<pre class="example">     EB_Position position;
     
     /* 関数の処理が成功すると、<code>position</code> に本文の開始位置が
      * 書き込まれます。 */
     if (eb_text(&amp;book, &amp;position) != EB_SUCCESS) {
         fprintf(stderr, "an error occurs.\n");
         return;
     }
     </pre>

<p>参考までに、<code>EB_Position</code> 型の内部構造は、次のようになっています。

<pre class="example">     typedef struct EB_Position_Struct EB_Position;
     
     struct EB_Position_Struct {
         int page;     /* ページ番号 */
         int offset;   /* ページ内のオフセット */
     };
     </pre>

   <p>ところで、検索時に一致したエントリの見出しや本文を読み込む際にも、
位置情報の指定には <code>EB_Position</code> 型が使われます。
一致したエントリの情報は、関数 <code>eb_hit_list()</code> によって
<code>EB_Hit</code> という型のオブジェクトに書き込まれますが、<code>EB_Hit</code>
型は次のように定義されています。
(詳しくは see <a href="Search-Data-Types.html#Search%20Data%20Types">[検索] データ型の詳細</a>。)

<pre class="example">     typedef struct {
         EB_Position heading;   /* 見出しの位置 */
         EB_Position text;      /* 本文の位置   */
     } EB_Hit;
     </pre>

<p>つまり、このときの見出しと本文の位置も、<code>EB_Position</code> 型で表現
されているのです。

   <p>では、実際のプログラムを例にして、シークと読み込みを行ってみます。
まずは、シークからです。
これには関数 <code>eb_seek_text()</code> を用います。
ここでもやはり、位置は <code>EB_Position</code> 型で渡します。

<pre class="example">     if (eb_seek_text(&amp;book, &amp;position) != EB_SUCCESS) {
         fprintf(stderr, "an error occurs.\n");
         return;
     }
     </pre>

<p>データの種類 (見出し、本文 ...) によらず、テキストデータのシークは
すべて <code>eb_seek_text()</code> で行います。

   <p>ただし、<code>EB_Book</code> オブジェクトは、テキストデータの種類別に読み込み
位置を覚えているわけではなく、全種類のテキストデータで共有する位置情報を
一つ覚えているだけです。
たとえば、本文を読み込んだ後で、別の位置にシークして見出しを読み込むと、
<code>EB_Book</code> は本文の読み込み位置のことは忘れてしまいます。

   <p>さて、シークが終わったら、データを読み込みます。
読み込もうとするテキストデータの種類によって、使用する関数が異なります。
見出しだけは <code>eb_read_heading()</code> を使いますが、それ以外では
<code>eb_read_text()</code> を使います。

   <p>以下は、<code>eb_read_text()</code> の使用例です。

<pre class="example">     #define MAX_LENGTH 1000
     char buffer[MAX_LENGTH + 1];
     ssize_t text_length;
     
     if (eb_read_text(&amp;book, NULL, NULL, NULL, MAX_LENGTH,
         text, &amp;text_length) != EB_SUCCESS) {
         fprintf(stderr, "an error occurs.\n");
         return;
     }
     </pre>

<p>成功すると、<code>text</code> にはテキストデータが、<code>text_length</code> には
実際に読み込んだバイト数が書き込まれます。
テキストは最大で <code>MAX_LENGTH</code> バイト書き込まれます。
テキストデータはさらにナル文字で終端されますので、<code>buffer</code> には
もう 1 バイト分の領域が必要になります。

   <p><code>eb_read_heading()</code> の呼び出し方も、<code>eb_read_text()</code> と
まったく変わりません。

<pre class="example">     if (eb_read_heading(&amp;book, NULL, NULL, NULL, MAX_LENGTH,
         text, &amp;text_length) != EB_SUCCESS) {
         fprintf(stderr, "an error occurs.\n");
         return;
     }
     </pre>

   <p><code>eb_read_text()</code> や <code>eb_read_heading()</code> で読み込んだ
テキストデータは平文のテキストになっていて、ナル文字で終端されています。

<pre class="example">     printf("%s\n", text);   /* 出力してみる */
     </pre>

   <p>読み込みたいテキストデータが長すぎて、<code>eb_read_text()</code> あるいは
<code>eb_read_heading()</code> を一回呼び出しただけでは全部読み込めなかった
場合は、再度呼び出すことで続きのデータを読み込むことができます。

   </body></html>

