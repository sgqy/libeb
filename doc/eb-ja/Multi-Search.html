<html lang="en">
<head>
<title>EB Library</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="EB Library">
<meta name="generator" content="makeinfo 4.5">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home">
</head>
<body>
<div class="node">
<p>
ノード:<a name="Multi%20Search">Multi Search</a>,
次:<a rel="next" accesskey="n" href="EB_Hit.html#EB_Hit">EB_Hit</a>,
前:<a rel="previous" accesskey="p" href="Keyword-Search.html#Keyword%20Search">Keyword Search</a>,
上:<a rel="up" accesskey="u" href="Search.html#Search">Search</a>
<hr><br>
</div>

<h3 class="section">複合検索</h3>

   <p>複合検索は、条件検索と同じく、複数個の入力語にすべて一致するエントリを
検索しますが、個々の入力語にあらかじめ題目が付けられています。

   <p>また、前方一致、後方一致、完全一致、条件検索はすべて、各副本につき
一種類しかありませんが、複合検索だけは一つの副本の中で複数の種類が用意
されていることがあります。
たとえば、ある世界人名事典には、次のように人名検索用と頻出用語の検索用
の 2 種類の複合検索が用意されているかも知れません。

<pre class="example">     (複合検索その 1: 人名を検索する)
         入力語 0: 国・地域
         入力語 1: 時代
         入力語 2: 性別
         入力語 3: キーワード
         入力語 4: キーワード
     </pre>

<pre class="example">     (複合検索その 2: 頻出用語を検索する)
         入力語 0: 用語
         入力語 1: キーワード
         入力語 2: キーワード
     </pre>

<p>この例のように、個々の複合検索は、入力語の題目だけでなく、入力語の数も
まちまちです。
また、検索する際はすべての入力語を埋める必要はなく、少なくとも一個の
入力語が空でなければ、検索は成功します。

   <p>副本内の複合検索は、種類毎に <dfn>複合検索コード (multi search code)</dfn>
によって識別されます。
関数 <code>eb_multi_search_list()</code> を使うと、選択中の副本で利用可能な
複合検索の一覧が得られます。

<pre class="example">     /* <code>book</code> が <code>EB_Book</code> のオブジェクトで、すでに書籍に結び付け
      * られ、副本を選択中だと仮定しています。*/
     EB_Multi_Search_Code multi_codes[EB_MAX_MULTI_SEARCHES];
     int multi_count;
     
     if (eb_multi_search_list(&amp;book, multi_codes, &amp;multi_count)
         != EB_SUCCESS) {
         printf("eb_multi_search_list() failed\n");
         return;
     }
     </pre>

<p>この複合検索コードは、複合検索のための関数で必要となります。
たとえば、<code>eb_multi_title()</code> は、指定した複合検索の題名
(例:「人名検索」「頻出用語検索」) を取得する関数ですが、このときの
複合検索の指定には、複合検索コードを用います。
以下の例では、一覧の先頭に載っている複合検索 (<code>multi_codes[0]</code>)
を指定しています。

<pre class="example">     char title[EB_MAX_MULTI_TITLE_LENGTH + 1];
     
     if (eb_multi_title(&amp;book, multi_codes[0], title)
         != EB_SUCCESS) {
         printf("eb_multi_title() failed\n");
         return;
     }
     </pre>

<p>さらに関数によっては、複合検索コードに加えて、何番目の入力語かも指定
してやる必要があります。
たとえば、特定の入力語の題目を得る関数 <code>eb_multi_entry_label()</code>
が、これに該当します。
0 番目の入力語 (つまり先頭の入力語) の題目を取得するには、次のように
します。

<pre class="example">     char label[EB_MAX_MULTI_LABEL_LENGTH + 1];
     
     if (eb_multi_entry_label(&amp;book, multi_code[0], 0, label)
         != EB_SUCCESS) {
         printf("eb_multi_entry_label() failed\n");
         return;
     }
     </pre>

   <p>複合検索を行う関数は、<code>eb_search_multi()</code> です。
使い方は条件検索とほぼ同じで、入力語の文字列を配列にしたものを引数
として渡し、配列の最後には <code>NULL</code> を置いて下さい。
埋められていない入力語のところには、空文字列を置きます。

   <p><code>eb_search_multi()</code> も検索のリクエストを行うだけで、一致した
エントリの取得は行いません。
取得するには <code>eb_hit_list()</code> を使います。

<pre class="example">     EB_Hit hits[MAX_HITS];
     int hit_count;
     
     if (eb_hit_list(&amp;book, MAX_HITS, hits, &amp;hit_count)
         != EB_SUCCESS) {
         fprintf(stderr, "an error occurs.\n");
         return;
     }
     </pre>

   <p>なお、複合検索の入力語によっては
<dfn>候補一覧 (candidates)</dfn> があらじめ用意されていることがあります。
これは、入力語として有効な語をあらかじめ列挙しておき、
アプリケーションプログラムのユーザに選択させる仕組みです。
候補一覧については、この章ではなく「テキストデータ」の章で説明します
(see <a href="Multi-Candidates.html#Multi%20Candidates">複合検索の候補一覧</a>)。

   </body></html>

